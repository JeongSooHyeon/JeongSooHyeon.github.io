---
title:  "[유데미X스나이퍼팩토리] 10주 완성 프로젝트 캠프 유니티 - 2주차"

categories:
  - UdemyXSniperFactory-PreJobTrainning
tags:
  - [프로젝트캠프후기, 유데미, udemy, 스나이퍼팩토리, 웅진씽크빅, 인사이드아웃, IT개발캠프, 개발자부트캠프, unity, 유니티, 게임개발, 메타버스 ]

toc: true
toc_sticky: true
 
date: 2023-09-18
last_modified_at: 2023-09-11
---
<br>

## 2023/09/18/월 4일차

**개념 정리**

Character Controller
- 물리엔진을 사용하지 않고 간단한 로직으로 움직임을 구현, 자체적으로 콜라이더를 생성

애니메이터
- Entry : 처음 시작하는 애니메이션을 설정, 1개만 가능
- 파라미터를 추가하여 조건에따라 애니메이션 발동

Is Trigger
- 물리적 연산을 하지 않고 충돌 감지(다른 GameObject와 접촉했을 때 그냥 통과)

Tag
- 오브젝트에 Tag를 추가해서 Scene에 해당 오브젝트가 얼마나 있는지 등을 확인 가능
- FindGameObjectsWithTag() : 해당 태그를 가진 활성 오브젝트 array을 반환

Navigation
- 유니티는 AI-Navigation을 지원
- NavMesh : 게임 월드에서 걸을 수 있는 표면, 움직일 수 있는 경로를 찾을 수 있다.
    - 장애물을 설치하고 Bake를 해야 함
- NavMesh Agent : NavMesh 위에서 움직이는 대상. 장애물을 피해 돌아다닐 수 있다.

LoadScene
- Scene의 이름, 번호를 이용하여 해당 Scene을 불러올 수 있다.

**과제**

*다양한 구조물로 새로운 맵을 만들기*

**결과**

1번 스테이지

![week2-1-1](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/e800c44c-8453-45b2-8263-4cef33f375c1)
- Shpere 오브젝트를 변형해 만들었다 나름 헷갈리게 하기 위해 Dot의 색을 흰색으로 변경했다.

2번 스테이지 

![week2-1-2](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/da7edd44-c96b-45b7-9206-5da00e24dac4)
- Cube를 붙여 여러 방향으로 회전시켰다. 지나갈 수 있는 틈과 좁아서 못지나가는 틈을 만들어 난이도를 올렸다.

**과제 회고**

역시 맵 만드는 노가다는 재미없고 힘들다.


## 2023/09/20/수 5일차

**개념 정리**

Camera의 Clear Flags
- 배경 설정
  - skybox(하늘)
  - solid color(단일 색상)
  - Depth only(투명 배경)
  - Don't clear(이전 프레임 지우지 않음, 잔상이 남음)

camera.main 
- 'MainCamera' 태그가 있는 GameObject의 첫번째 활성화된 카메라
- GameObject.GetComponent 호출보다 CPU 오버헤드가 적다!

mousePosition 
- 좌측 
Input.GetAxis()
- -1.0f ~ +1.0f 범위의 값 반환
- 부드러운 이동시 사용
- 문자열로 식별되는 가상축의 값을 반환
- 마우스가 오른쪽,위로 움직이면 양수
- 왼쪽,아래로 움직이면 음수 반환

Input.GetAxis()
- -1, 0, 1 중 하나를 반환
- 키보드처럼 즉시 반응시 사용

AudioSource
- Play() : 오디오 클립 재생
- playOneShot()
  - 이미 재생중인 클립을 취소하지 않음

Ray
- 원점에서 시작하여 어떠한 방향으로 무한히 가는 선
- Physics.Raycast(ray, out hit, 100)
  - ray에 맞은 물체가 있다면 true, 아니면 false 반환
  - ray : 선 쏜 거
  - hit : ray에 맞은 물체 반환(RaycastHit 타입)
    - out을 써주면 함수가 실행돼서 나온 결과물이 들어감
  - 100 : 선의 길이

Animator.StringToHash("Base Layer.Idol");
- Animator Controller의 Parameters의 ID를 반환

GetCurrentAnimatorStateInfo(int layerIndex)
- 현재 상태의 AnimatorStateInfo를 반환

animator.GetCurrentAnimatorStateInfo(0).fullPathHash
- 최근 재생 중인 Animator의 hash값 반환

Rect
- x,y 위치와 너비, 높이에 의해 정의되는 2차원 사각형 영역
- UI의 가로, 세로, 카메라의 위치 등의 정보를 알고자 할 때 사용

System.DateTime.Now
- 현재의 년/월/일/시/분/초/밀리초/요일 정보 제공

PlayerPrefs 클래스
- 간단한 설정들을 저장
- 로컬 레지스트리에 데이터를 저장

**과제 요구사항**

*버튼 UGUI로 변경하기*

**코드작성**

Button을 관리하는 코드

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class UIButton : MonoBehaviour
{
    public Button buttonGame;
    public GameObject buttonGrid;
    public Button buttonGoo;
    public Button buttonChoki;
    public Button buttonPar;

    public JanKen janken;

    void Update()
    {
        setActiveGameBtn();
    }

    void setActiveGameBtn()
    {
        if (!janken.GetFlagJanken())
        {
            buttonGame.gameObject.SetActive(true);
        }
        else if (janken.GetModeJanken() == 1)
        {
            buttonGoo.gameObject.SetActive(true);
            buttonChoki.gameObject.SetActive(true);
            buttonPar.gameObject.SetActive(true);
        }
    }

    public void ClickStart()
    {
        buttonGame.gameObject.SetActive(false);
        janken.SetFlagJanken(true);
        buttonGrid.SetActive(true);
    }

    public void ClickGOO()
    {
        janken.WaitInput("GOO");
        SetActiveFalse();
    }
    public void ClickCHOKI()
    {
        janken.WaitInput("CHOKI");
        SetActiveFalse();
    }
    public void ClickPAR()
    {
        janken.WaitInput("PAR");
        SetActiveFalse();
    }

    void SetActiveFalse()
    {
        buttonGoo.gameObject.SetActive(false);
        buttonChoki.gameObject.SetActive(false);
        buttonPar.gameObject.SetActive(false);
    }
}
```

- Janken 스크립트에서 사용하던 변수를 Getter() 함수로 받아와 버튼들의 활성화와 비활성화를 설정
  - Janken의 flagJanken(묵찌빠 시작 플래그) 변수가 true면 게임시작 버튼, false면 묵찌빠 버튼을 활성화
- buttonGame 버튼의 OnClick에 ClickStart() 함수를 추가하고 버튼을 누르면 버튼이 비활성화 되고 janken의 flagJanken 변수를 true로 설정한 후 묵찌빠 버튼들을 활성화
- 묵찌빠 버튼들에는 각각 ClickGOO(), ClickCHOKI(), ClickPAR() 함수를 추가해서 버튼이 눌렸을 때 자신의 이름을 Janken의 WaitInput() 함수에 전달 후 묵찌빠 버튼들을 비활성화

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class JanKen : MonoBehaviour
{
    bool flagJanken = false;    // 묵찌빠 시작 플래그
    int modeJanken = 0;         // 게임 모드

    public AudioClip voiceStart;
    public AudioClip voicePon;
    public AudioClip voiceGoo;
    public AudioClip voiceChoki;
    public AudioClip voicePar;
    public AudioClip voiceWin;
    public AudioClip voiceLoose;
    public AudioClip voiceDraw;

    const int JANKEN = -1;
    const int GOO = 0;
    const int CHOKI = 1;
    const int PAR = 2;
    const int DRAW = 3;
    const int WIN = 4;
    const int LOOSE = 5;

    private Animator animator;
    private AudioSource univoice;

    int myHand;
    int unityHand;
    int flagResult;
    int[,] tableResult = new int[3, 3];

    float waitDelay;



    void Start()
    {
        animator = GetComponent<Animator>();
        univoice = GetComponent<AudioSource>();

        // 결과 테이블 미리 결정 [유니티짱, 플레이어]
        tableResult[GOO, GOO] = DRAW;
        tableResult[GOO, CHOKI] = WIN;
        tableResult[GOO, PAR] = LOOSE;
        tableResult[CHOKI, GOO] = LOOSE;
        tableResult[CHOKI, CHOKI] = DRAW;
        tableResult[CHOKI, PAR] = WIN;
        tableResult[PAR, GOO] = WIN;
        tableResult[PAR, CHOKI] = LOOSE;
        tableResult[PAR, PAR] = DRAW;
    }

    void Update()
    {        
        // 묵찌빠 상태이면
        if (flagJanken)
        {
            // 게임 모드에 따라
            switch (modeJanken)
            {
                case 0: // 묵찌빠 시작
                    UnityChanAction(JANKEN);
                    modeJanken++;
                    break;

                case 1: // 플레이어 입력 대기
                    // 애니메이션 초기화
                    animator.SetBool("Janken", false);
                    animator.SetBool("Aiko", false);
                    animator.SetBool("Goo", false);
                    animator.SetBool("Choki", false);
                    animator.SetBool("Par", false);
                    animator.SetBool("Win", false);
                    animator.SetBool("Loose", false);
                    break;

                case 2: // 판정
                    flagResult = JANKEN;
                    // 유니티짱의 손을 무작위로 선택
                    unityHand = Random.Range(GOO, PAR + 1);
                    // 유니티짱 액션
                    UnityChanAction(unityHand);
                    // 결과
                    flagResult = tableResult[unityHand, myHand];
                    modeJanken++;
                    break;

                case 3: // 결과
                    // 약간의 시간 간격
                    waitDelay += Time.deltaTime;
                    if(waitDelay > 1.5f)
                    {
                        // 유니티짱 결과 액션
                        UnityChanAction(flagResult);

                        waitDelay = 0;
                        modeJanken++;
                    }
                    break;

                default:    // 게임 끝내고 초기화
                    flagJanken = false;
                    modeJanken = 0; // 묵찌빠 버튼 없어짐
                    break;
            }
        }
    }

    public bool GetFlagJanken()
    {
        return flagJanken;
    }
    public void SetFlagJanken(bool flag)
    {
        flagJanken = flag;
    }
    public int GetModeJanken()
    {
        return modeJanken;
    }
    public void WaitInput(string choice)
    {
        switch (choice)
        {
            case "GOO":
                myHand = GOO;
                modeJanken++;
                break;

            case "CHOKI":
                myHand = CHOKI;
                modeJanken++;
                break;

            case "PAR":
                myHand = PAR;
                modeJanken++;
                break;
        }
    }


    // 유니티짱의 액션
    void UnityChanAction(int act)   // 이벤트 함수
    {
        switch(act){
            case JANKEN:
                animator.SetBool("Janken", true);
                univoice.clip = voiceStart;
                break;

            case GOO:
                animator.SetBool("Goo", true);
                univoice.clip = voiceGoo;
                break;

            case CHOKI:
                animator.SetBool("Choki", true);
                univoice.clip = voiceChoki;
                break;

            case PAR:
                animator.SetBool("Par", true);
                univoice.clip = voicePar;
                break;

            case DRAW:
                animator.SetBool("Aiko", true);
                univoice.clip = voiceDraw;
                break;

            case WIN:
                animator.SetBool("Win", true);
                univoice.clip = voiceWin;
                break;

            case LOOSE:
                animator.SetBool("Loose", true);
                univoice.clip = voiceLoose;
                break;

        }
        univoice.Play();
    }
}

```
- flagJanken 변수와 modeJanken 변수의 getter, setter 함수들을 추가해서 UIButton 스크립트에서 flagJanken 변수를 활용
- WaitInput() : UIButton 스크립트로부터 반환받은 문자열에따라 myHand 변수 설정, 모드 변경

![button_capture](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/a19c63fe-6b46-4d99-a8ca-38f591c4a6a8)

- 버튼들은 Game버튼 하나 따로, 나머지 묵찌빠 버튼은 Horizontal Layout Group 컴포넌트를 추가한 빈 오브젝트에 넣어 생성

![button_inspector](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/f940b65c-f4f2-4a76-ab07-d27f4903c24a)

- Source Image에 기본 이미지를 넣고, Highlighted Sprite에 마우스를 올렸을 때의 이미지, Pressed Sprite에 클릭시 이미지를 넣음

**결과**

게임 시작시 이미지

![janken_ready](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/930618ec-eddc-4590-801a-c9f2e91d97f2)

마우스를 올렸을 때

![janken_highlighted](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/379c8a20-b6f8-409c-b91f-db7bb886ac70)

클릭했을 때

![janken_pressed](https://github.com/JeongSooHyeon/Algorithm/assets/82567002/38d6aec0-a322-469d-aeb4-30448e07fd7f)



**과제 회고(느낀점)**

- 저번수업보다 갑작스럽게 난이도가 상승한 것같다. 오히려 더 재밌어졌다.
- 버튼 UI를 만들면서 스크립트를 작성하는데 기능을 어떤 스크립트에 넣어야 효율적인지 구분하는 게 어렵다. 전부터 항상 헷갈렸던 부분이다. 
