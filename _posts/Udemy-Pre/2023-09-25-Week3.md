---
title:  "[유데미X스나이퍼팩토리] 10주 완성 프로젝트 캠프 유니티 - 3주차"

categories:
  - UdemyXSniperFactory-PreJobTrainning
tags:
  - [프로젝트캠프후기, 유데미, udemy, 스나이퍼팩토리, 웅진씽크빅, 인사이드아웃, IT개발캠프, 개발자부트캠프, unity, 유니티, 게임개발, 메타버스 ]

toc: true
toc_sticky: true
 
date: 2023-09-25
last_modified_at: 2023-09-26
---
<br>

## 2023/09/25/월 7일차

수업 시간에 오류가 있는 게임을 수정하는 시간을 가졌다. 알고리즘을 사용해서 풀고 싶었지만 무리였다.. 알고리즘 공부를 더 열심히 해야겠다.

**개념 정리**

스크립트를 볼 때
- 맵틀을 가장 먼저 봐라

설정 카메라 명칭
1. Top View
- 위에서 수직으로 바닥을 바라 봄
2. Side View
- 옆에서 수평으로 바라 봄
- 위,아래 이동이 용이
- 장점 : 거리 계산이 쉽다
3. Quater View
- 대각선 각도로 바닥을 바라 봄
- 입체적 지형 표현이 용이
- 단점 : 외곡이 심하다
4. First Person View
- 주인공의 눈 시점
- 조종 캐릭터의 시각에서 주변을 바라 봄
5. Second Person View
- 조연의 눈 시점
- 조종하는 캐릭터를 옆에 존재하는 사물의 시각으로 바라 봄
6. Third Person View
- 전지적 시점
- 장면 전체를 외부의 자유롭게 이동하는 시각으로 관찰

클래스 상속을 사용하는 이유
- 동일한 기능은 부모 클래스에서
- 차이나는 기능은 상속받은 자식 클래스에서 진행

게임 AI
- 인식 -> 판단 -> 행동

Path Finding(길찾기 알고리즘)
- Graph Search Algorithm
    - Greedy Algorithm
    - Dijkstra's Algorithm
    - A* Algorithm
        - 다익스트라보다 더 많이 사용

Navigation Mesh
- Path Smoothing
    - Path를 짧게 하기 위한 지점만 추가
    - 경로 탐색 노드 수는 그대로
    - 전체적인 비용 증가 매우 적음

Flocking Algorithm(군중 이동 알고리즘)
 - 새 떼나 물고기들의 움직임 등 여러 집단이 함께 움직이는 모습 구현

**과제 요구사항**

*포트폴리오 만들기*

**코드작성**

Player_Base 스크립트 - 추가 부분

```c#
// 게임 끝
public void setFinish()
{
    // 애니메티어를 얻는다
    Animator animator = playerObject.GetComponent<Animator>();

    // 사망했다는 사실을 알린다
    animator.SetBool("Dead", true);     // 사망 플래그
    isDead = true;
    // 이 플레이어는 죽은 상태로 설정
    m_playerDeadFlag = true;
    Debug.Log("R키를 눌러 게임을 다시 시작하시오");
}

private void OnTriggerEnter(Collider hitCollider)
{
    // 닿아도 되는지 확인한다
    if (false == IsHitOK(hitCollider.gameObject))
    {
        // 이 오브젝트에 닿아서는 안 된다
        return;
    }

    // 총알에 맞앗다
    attackedCnt++;

    // 히트 효과가 잇는지 판정
    if (null != hitEffectPrefab)
    {
        // 자신의 현재 위치에서 히트 효과를 낸다
        Instantiate(hitEffectPrefab, transform.position, transform.rotation);
    }
}
```
- setFinish() : 원래 OnTriggerEnter()에 있던 코드를 밖으로 빼서 총알이 닿았을 때 사망하는 게 아니고, TextUI 스크립트에서 호출할 때 사망 설정을 한다
- OnTriggerEnter()에는 총알에 맞았을 때 attackedCnt 변수를 증가시킨다

TextUI 스크립트

```c#
using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class TextUI : MonoBehaviour
{
	private float timer = 15.0f;	// 게임 플레이 시간
	private Text timerText;	// 시간 표시할 Text UI
	public Text aiScore;	// ai의 점수 Text
	public Text playerScore;	// 휴먼의 점수 Text

	private Player_Base AIPlayer;	
	private Player_Base Player;

	public GameObject finish;	// finish UI
	private string victory;	// 승리한 사람의 텍스트

	private float waitTime = 2.0f;	// 게임이 끝나고 애니메이션이 끝까지 실행될 때까지 기다리는 시간

	private int aiCnt;	// 맞은 count
	private int playerCnt;	// 맞은 count

	private bool isFinish = false;	// 게임 끝남

	private void Start()
	{
		timerText = GetComponent<Text>();
		AIPlayer = GameObject.FindGameObjectWithTag("AI").GetComponent<Player_Base>();
		Player = GameObject.FindGameObjectWithTag("Player").GetComponent<Player_Base>();
	}

	private void Update()
	{
		// 게임 실행 시간 세기
		if (timer > 0)
			timer -= Time.deltaTime;


		// Timer
		setTimer();

		// UI 표시
		timerText.text = timer.ToString("F0");
		aiScore.text = "AI : " + aiCnt.ToString();
		playerScore.text = "휴먼 : " + playerCnt.ToString();
	}

	// 게임 멈추기
	void pauseGame()
	{
		waitTime -= Time.deltaTime;
		if ((int)waitTime <= 0)
		{
			Time.timeScale = 0;
		}
	}

	void setTimer()
	{
		aiCnt = AIPlayer.attackedCnt;
		playerCnt = Player.attackedCnt;

		if ((int)timer <= 0 && !isFinish)
		{
			if (aiCnt > playerCnt)  // 사람이 이김
			{
				victory = "휴먼 승!";
				AIPlayer.setFinish();	// AI의 사망 애니메이션 실행
			}
			else if (aiCnt < playerCnt) // AI 이김
			{
				victory = "AI 승!";
				Player.setFinish();	// 사람의 사망 애니메이션 실행
			}
			else // 비김
			{
				victory = "비겼다 !";
			}

			isFinish = true;
			finish.SetActive(true);
			finish.GetComponent<Text>().text = victory;
		}
		if(isFinish)
			pauseGame();
	}
}
```

- 게임 실행 시간을 관리
- 시간이 끝나면 각 캐릭터의 스크립트를 받아와 맞은 횟수를 비교해서 진 사람의 사망 애니메이션을 실행 후 스크립트도 변경한다.

**결과**

UI 상태

<img width="543" alt="week3-1_UI" src="https://github.com/JeongSooHyeon/Algorithm/assets/82567002/30de1e0b-339a-4a67-b192-456b7412990f">

Timer가 계속 줄어든다

<img width="550" alt="week3-1_Timer" src="https://github.com/JeongSooHyeon/Algorithm/assets/82567002/cc98daf8-64f5-4473-8c5f-71b4eb7176fb">

사람이 이겼을 때 UI

<img width="545" alt="week3-1_Ending" src="https://github.com/JeongSooHyeon/Algorithm/assets/82567002/27ae7dfa-2892-49fb-b50c-04d8fd8ca867">

AI가 이겼을 때 UI

<img width="542" alt="week3-1_Ending2" src="https://github.com/JeongSooHyeon/Algorithm/assets/82567002/37f855ce-736d-40bd-8ae0-e3dcd8119bd5">

비겼을 때

<img width="542" alt="week3-1_Ending3" src="https://github.com/JeongSooHyeon/Algorithm/assets/82567002/51b41ae7-ff74-47e9-9a96-817d7f1a0bce">

**과제 회고**

UI 스크립트에 게임의 타이머와 승패 판정까지 작성한 게 아쉽다 어쩌다 완성하고 보니 이렇게 돼 있었다. 스크립트 관리를 더 깔끔하게 하도록 생각하며 코드를 짜야겠다. 그리고 언젠간 알고리즘으로 수업시간에 못푼 오류를 꼭 풀고 말거다. 그래서 오늘 Field와 Player 스크립트들을 열심히 정독해놨다.