---
title:  "[윤성우 열혈 C++ 프로그래밍] Chapter03_클래스의 기본"

categories:
  - Cpp
tags:
  - [Programming, Cpp]

toc: true
toc_sticky: true
 
date: 2023-05-03
last_modified_at: 2023-05-03
---
<br>

## 03-1 C++에서의 구조체

**구조체의 등장배경은 무엇인가?**
- 구조체의 이점 : 연관있는 데이터를 하나로 묶으면, 프로그램의 구현 및 관리가 용이하다.
- 소프트웨어 = 데이터의 표현 + 데이터의 처리(함수)
  - 표현해야 하는 데이터는 부류를 형성, 부류를 형성하는 데이터들은 함께 생성, 이동 및 소멸된다

*<u>구조체는 연관 있는 데이터를 묶을 수 있는 문법적 장치로 데이터의 표현에 큰 도움을 준다.</u>*

<br>

**C++에서의 구조체 변수의 선언**

- C언어에서 구조체 변수 선언 방법

    ```c++
    struct Car basicCar;
    ```
    - 키워드 `struct`를 생략하려면 별도의 `typedef` 선언을 추가해야 한다.

- C++에서는 기본 자료형 변수의 선언방식과 구조체를 기반으로 정의된 자료형의 변수 선언 방식에 차이가 없다.

    ```c++
    Car basicCar;
    ```
    - 별도의 `typedef` 선언 없이도 변수 선언 가능

<br>

**구조체 안에 함수 삽압하기**
- 구조체에 종속적인 함수들을 구조체 안에 함께 묶으면 다른 영역에서 이 함수들을 호출하는 실수를 면할 수 있다.
- 구조체 변수를 각각 선언하면 <u>모든 해당 구조체의 변수가 하나의 함수를 공유</u>한다. 다만 논리적으로 자신의 함수를 별도로 지니는 것과 같은 효과 및 결과를 보인다.

<br>

**문제 03-1 [구조체 내에 함수정의하기]**

```c++
struct Point{
    int xpos;
    int ypos;

    void MovePos(int x, int y){ // 점의 좌표이동
        xpos += x;
        ypos += y;
    }
    void AddPoint(const Point &pos){    // 점의 좌표증가
        xpos+=pos.xpos;
        ypos+=pos.ypos;
    }
    void ShowPosition(){
        cout << "[" << xpos << ", " << ypos << "]" << endl;
    }
}
```

<br>

**구조체 안에 enum 상수의 선언**

<u>어떠한 구조체에게만 의미있는 (매크로)상수</u>들(다른 영역에서 사용하도록 정의된 상수가 아닌)도 구조체 내에 포함시키는 것이 좋을 수 있다.

```c++
struct Car
{
  enum{
    ID_LEN  = 20,
    MAX_SPD = 200,
    BRK_STEP  = 10
  };
}
```
- `열거형 enum`을 이용해서 구조체 내에서만 유효한 상수를 정의
- 구조체 내에 삽입하는 것이 부담스럽다면 `이름공간`을 이용해서 상수가 사용되는 영역을 명시하는 방법도 있다.
  - 몇몇 구조체들 사이에서만 사용하는 상수들을 선언할 때 좋음
  - 가독성도 좋아짐

<br>

**함수는 외부로 뺄 수 있다.**

함수가 포함되어 있는 C++의 구조체를 보고 <u>코드의 분석이 용이</u>하려면 다음의 정보들이 쉽게 눈에 들어와야 한다.
 - 선언되어 있는 `변수 정보`
 - 정의되어 있는 `함수 정보`(종류, 기능)
   - <u>정의된 함수의 수가 많거나 길이가 길다면 밖으로 함수를 빼낼 필요가 있다!</u>

구조체 안에 함수가 정의되어 있다면 ? <br>
-> *함수를 `인라인`으로 처리해라*는 의미

<br>

## 03-2 클래스(Class)와 객체(Object)

C++의 구조체는 클래스의 일종이다.

**클래스와 구조체의 유일한 차이점**
- 키워드 struct 대신 `class`를 사용
- 클래스는 정의 과정에서 변수 및 함수의 접근 허용범위를 별도로 선언해야 함

<br>

**접근제어 지시자(접근레어 레이블)**
- `public` : 어디서든 접근 허용
- `protected` : 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용
- `private` : 클래스 내(클래스 내에 정의된 함수)에서만 접근 허용

- 키워드 `struct`를 이용해 정의한 구조체의 디폴트 접근제어 지시자는 `public`이다.
- 키워드 `class`를 이용해 정의한 클래스의 디폴트 접근제어 지시자는 `private`이다.

- 참고) 레이블
  - 접근제어 지시자 뒤에 콜론(:)이 붙는 이유는 접근제어 지시자가 특정 위치정보를 알리는 `레이블(라벨)`이기 때문(switch문에 사용되는 case도 레이블)

<br>

**C++에서의 파일분할**

**알고 있어야 할 내용**

- 헤더 파일의 역할 : 함수의 선언부를 모아놓은 파일, 관리 및 사용이 쉬워짐, 분할 컴파일 시 여러 소스 코드들이 공유해야 할 정보의 공유를 위함
- C언어를 대상으로 헤더파일에 들어가야 할 내용 : 사용자 정의 구조체, 데이터형 정의, 클래스, 함수, 매크로 등의 프로토 타입
- 매크로 #ifdef~#endif : 이 전처리기를 사용하는 이유는 다수의 소스코드에서 include된 헤더 파일이 중복 포함되는 것을 막기 위함
- 둘 이상의 파일을 컴파일해서 하나의 실행파일을 만드는 법(분할 컴파일) : 여러 개의 소스 코드들을 따로 컴파일 한 후 만들어진 파일들을 링크하여 실행 파일을 만든다.
- Linker의 역할 : obj 파일(컴파일러가 소스코드를 컴퓨터가 이해할 수 있는 저급 언어로 바꿔준 것)이 여러가지 있을 때 엮어서 연결하여 최종적으로 실행 파일을 만드는 것<br><br>

---

- **Car.h** : `클래스의 선언`을 담는다.
  - 클래스의 선언(declaration) : 클래스를 구성하는 외형적인 `틀`, 컴파일러가 Car 클래스와 관련된 <u>문장의 오류를 잡아내는 데 필요한 최소한의 정보</u>
  
  ```c++
  int main(void){
    Car run99;
    run99.fuelGauge = 100;  // fuelGauge가 private임을 확인하고 에러 발생
    run99.Accel(20);  // Accel 함수의 매개변수가 void형임을 알고 에러 발생
  }
  ```

- **Car.cpp** : `클래스의 정의`(멤버함수의 정의)를 담는다.
  - 클래스의 정의(definition) : 함수의 정의는 다른 문장의 컴파일에 필요한 정보를 가지고 있지 않음, 컴파일 된 이후에 링커에 의해 하나의 실행파일로 묶이기만 하면 된다.

<br>

**<u>인라인 함수</u>는 <u>헤더파일</u>에 함께 넣어야 해요.**

함수를 인라인화 한 다음 소스파일에 두면 컴파일 에러 발생
- 컴파일 과정에서 함수의 호출 문이 있는 곳에 함수의 몸체 부분이 삽입되어야 함
- 클래스의 선언과 동일한 파일에 저장되어서 컴파일러가 동시에 참조할 수 있게 해야 함

<br>

**문제 03-2 [클래스의 정이]**

**문제1) Calculator 클래스 정의**

```c++
class Calculator{
  private:
    int AddCnt; int MinusCnt; int MultCnt;  int DivCnt;
  public:
  void Init(){
    AddCnt=0; MinusCnt=0; Multcnt=0;  DivCnt=0;
  }
  double Add(double a, double b){
    AddCnt++;
    return a+b;
  }
  void ShowOpCount(){
    cout << "덧셈 : " << AddCnt;
  }
}
```

**문제2) Printer 클래스 정의**

```c++
class Printer{
  private:
    char str[100];
  public:
  void SetString(const char* str){
    strcpy(this.str, str);
  }
  void showString(){
    cout << str;
  }
}
```

<br>

## 03-3 객체지향 프로그래밍의 이해

**객체지향 프로그래밍의 이해**

객채(Object) : 사물 또는 대상

*객체지향 프로그래밍 : <u>현실에 존재하는 사물과 대상, 그에 따른 행동을 있는 그대로 실체화 시키는 형태의 프로그래밍</u>*

<br>

**객체를 이루는 것은 데이터와 기능입니다.**

*객체는 하나 이상의 <u>상태 정보</u>(데이터)와 하나 이상의 <u>행동</u>(기능)으로 구성*
- 상태 정보 : `변수`
- 행동 : `함수`

<br>

**과일장수의 정의와 멤버변수의 상수화에 대한 논의**

가격을 상수라고 가정하여 const 선언을 하여 값의 변경이 일어나지 않았으면 좋겠다.

```c++
const int APPLE_PRICE = 1000; // xxx 불가능
```
- 클래스의 멤버변수 선언문에서 초기화까지 하는 것은 허용하지 않음

```c++
const int APPLE_PRICE;  // XXX 불가능
```
- 선언 후 Init함수를 통해 상수 값 초기화??
  - 상수는 선언과 동시에 초기화되어야 하기 때문에 불가능

<br>

**클래스 기반의 두 가지 객체 생성 방법**

```c++
ClassName objName;                  // 일반적인 변수의 선언방식
ClassName * ptrObj = new ClassName; // 동적 할당 방식(힙 할당방식)
```

객체를 생성하지 않고 클래스 안에 존재하는 변수에 접근하고, 함수를 호출하는 것이 가능할까?<br>
-> XXX불가능, `객체`가 아닌 `틀`이기 때문

<br>

**객체간의 대화 방법(Message Passing 방법)**

하나의 객체가 다른 하나의 객체에게 메시지를 전달하는 방법은 함수호출을 기반으로 한다.
  - 이러한 함수호출을 가리켜 `메시지 전달(Message Passing)`이라 한다.