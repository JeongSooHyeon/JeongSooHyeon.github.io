---
title:  "[윤성우 열혈 C++ 프로그래밍] Chapter08_상속과 다형성"

categories:
  - Cpp
tags:
  - [Programming, Cpp]

toc: true
toc_sticky: true
 
date: 2023-05-12
last_modified_at: 2023-05-12
---
<br>

## 08-1 객체 포인터의 참조관계

**객체 포인터 변수 : 객체의 주소 값을 저장하는 포인터 변수**

```c++
Person * ptr;   // 포인터 변수 선언
ptr = new Person(); // 포인터 변수의 객체 참조
```

Person형 포인터가 가리킬 수 있는 객체
- Person 객체
- **Person을 상속하는 유도 클래스의 객체**

```c++
class Student : public Person
{
    ...
};

int main(){
    Person * ptr = new Student();
}
```

```c++
class PartTimeStudent : public Student
{
    ...
};

int main(){
    Person * ptr1 = new PartTimeStudent();
    Student * ptr2 = new ParTimeStudent();
}
```

*C++에서 AAA형 포인터 변수는 AAA 객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있다.*

왜 이러한 일이 가능한가?
이것이 C++에서 어떠한 의미가 있을까?

**유도 클래스의 객체까지 가리킬 수 있다니!**

위의 예제는 IS-A 관계가 성립한다.
- Student는 Person이다. (Student는 Person의 일종이다.)
- PartTimeStudent는 Student이다.
- PartTimeStudent는 Person이다.

-> 실제로 객체지향에서는 위의 문장들이 성립함으로 인해서 Student 객체와 PartTimeStudent 객체를 Person 객체의 일종으로 간주
  - 때문에 Person형 포인터 변수를 이용해서 Student 객체와 PartTimeStudent 객체를 가리킬 수 있는 것
  - Student형 포인터 변수를 이용해서 PartTimeStudent 객체를 가리킬 수 있는 것이다. 

**'오렌지미디어 급여관리 확장성 문제'의 1차적 해결과 함수 오버라이딩** 

EmployeeHandler 클래스가 저장 및 관리하는 대상이 Employee 객체가 되게 하면, 이후에 Employee 클래스를 직접 혹은 간접적으로 상속하는 클래스가 추가되었을 때, EmployeeHandler 클래스에는 변화가 발생하지 않는다.

함수 오버라이딩(function overriding)
- 기초 클래스의 함수와 동일한 이름과 형태로 유도 클래스에 함수를 정의
- 오버라이딩된 기초 클래스의 함수는 오버라이딩을 한 유도 클래스의 함수에 가려진다.
  - `기초클래스이름::함수이름()` : 클래스의 이름을 명시함으로써 기초 클래스의 오버라이딩된 함수를 호출할 수 있다.
  - `유도클래스객체.기초클래스이름::함수이름()` : 유도클래스 객체의 기초클래스에 정의된 함수를 호출해라

참고) 함수 오버라이딩 vs 함수 오버로딩
기초 클래스와 동일한 이름의 함수를 유도 클래스에서 정의한다고 해서 무조건 함수 오버라이딩이 되는 것은 아님. <u>매개변수의 자료형 및 개수가 다르면 함수 오버로딩</u>이 되어, 전달되는 인자에 따라서 호출되는 함수가 결정된다. 즉, 함수 오버로딩은 상속의 관계에서도 구성이 될 수 있다.

**SalesWorker 클래스에서 ShowSalaryInfo 함수를 오버라이딩 한 이유는?**

```c++
class PermanentWorker : public Employee{
public:
    int GetPay() const { return salary; }
    void ShowSalaryInfo() const{
        ShowYourName();
        cout << "salary : " << GetPay() << endl;
    }
};

class SalesWorker : public PermanentWorker{
public:
    int GetPay() const{
        return PermanentWorker::GetPay() + (int)(salesResult * bonusRatio);
    }
    void ShowSalaryInfo() const{
        ShowYourName();
        cout << "salary : " << GetPay() << endl;    // SalesWorker의 GetPay 함수가 호출됨
    }
};
```

두 클래스의 ShowSalaryInfo() 함수는 완전히 동일한데 굳이 오버라이딩한 이유는?
- SalesWorker의 GetPay() 함수가 호출되도록 별도로 정의해야만 한다.

## 08-2 가상함수(Virtual Function)

**기초 클래스의 포인터로 객체를 참조하면,**

```c++
class Base{
public:
    void BaseFunc() { }
};

class Derived : public Base(){
public:
    void DerivedFunc() {}
};
```

```c++
Base * bptr = new Derived();    // 컴파일 OK!
bptr->DerivedFunc();    // 컴파일 Error!
```
- `bptr->DerivedFunc();`는 컴파일 에러를 발생, btpr이 Base형 포인터이기 때문

*C++ 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단하지, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다.*

```c++
int main(){
    Base * bptr = new Derived();    // 컴파일 OK
    Derived * dptr = bptr;  // 컴파일 Error
}
```

- 컴파일러는 bptr이 실제로 가리키는 객체가 Derived 객체라는 사실을 기억하지 않음
- bptr은 Base형 포인터이니까 bptr이 가리키는 대상은 Base 객체일 수도 있으니 컴파일 에러 !

```c++
int main(){
    Derived * dptr = new Derived();    // 컴파일 OK
    Base * bptr = dptr;  // 컴파일 OK
}
```

- dptr은 Derived 클래스의 포인터 변수니까, Base 클래스를 직접 혹은 간접적으로 상속하는 객체이다. 그러니 Base형 퐁니터 변수로도 참조가 가능!

참조) 컴파일러가 바보같다고 생각이 되나요?
불필요한 포인터 연산을 허용하지 않음으로써 문제의 발생확률을 최소화시킬 수 있도록 정의된 C++의 문법에 근거한 것!

**위에서 한 이야기의 복습**