---
title:  "[윤성우 열혈 C++ 프로그래밍] Chapter04_클래스의 완성"

categories:
  - Cpp
tags:
  - [Programming, Cpp]

toc: true
toc_sticky: true
 
date: 2023-05-03
last_modified_at: 2023-05-03
---
<br>

## 04-1 정보은닉(Information Hiding)
좋은 클래스가 되기 위한 최소한의 조건
- 정보은닉
- 캡슐화

**정보은닉의 이해**

```c++
class Point{
public:
    int x; 
    int y;
};

class Rectangle{
public:
    Point upLeft;
    Point lowRight;
}
int main(){
    Point pos1 = {-2, 4};   // 멤버 변수가 public으로 선언되면 구조체 변수를 초기화하듯이 초기화 가능
    Point pos2 = {5, 9};
    Rectangle rec = {pos2, pos1};
}
```

- 문제
  - 점의 좌표가 0이상 100이하를 벗어나는 Point 객체가 있다.
  - Rectangle 객체의 좌 상단 좌표 값이 우 하단 좌표 값보다 크다.

프로그래머의 실수에 대한 대책이 하나도 준비되어 있지 않다!
-> *<u>제한된 방법으로의 접근만 허용</u>해 잘못된 값이 저장되지 않도록 도와야 하고, <u>실수를 쉽게 발견</u>할 수 있도록 해야 한다.*

변경된 Point 클래스

```c++
class Point{
private:
    int x;
    int y;
public:
    bool Init(int xpos, int ypos){
        if(xpos < 0 || ypos < 0){
            cout << "벗어난 범위의 값 전달" << endl;
            return false;
        }
        x = xpos;   y = ypos;
        return true;
    }

    int GetX() const { return x; }
    bool SetX(int xpos){
        if(0 > xpos || xpos > 100){
            cout << "벗어난 범위의 값 전달" << endl;
            return false;
        }
        x = xpos;
        return true;
    }
}
```

- 멤버변수를 private으로 선언, 해당 변수에 접근하는 함수를 별도로 정의
  - 안전한 형태로 멤버변수의 접근을 유도하는 것이 `정보은닉`
- GetX, SetX 함수를 `엑세스 함수(access function)`이라 함
  - 클래스 외부에서의 멤버변수 접근 목적

**const 함수**

```c++
int GetX() const;
void ShowRecInfo() const;
```

-> 이 함수 내에서는 *<u>`멤버변수`에 저장된 값을 변경하지 않겠다</u>*는 의미
  - const 멤버함수 내에서 멤버변수의 값을 변경하는 코드가 삽입되면 컴파일 에러 발생

```c++
class SimpleClass{
public:
    int GetNum(){   // const 선언이 추가되어야 컴파일 에러 소멸
        return num;
    }
    void ShowNum() const{
        cout << GetNum() << endl;   // 컴파일 에러 발생
    }
}
```

- const 함수 내에서는 const가 아닌 함수의 호출이 제한된다!
  - 비 const 함수는 멤버변수에 저장된 값을 변경하지 않더라도 <u>변경할 수 있는 능력을 지닌 함수</u>

```c++
class SimpleClass{
public:
    int GetNum(){   // const 선언이 추가되어야 컴파일 에러 소멸
        return num;
    }
}

class LiveClass{
public:
    void Init(const EasyClass &easy){
        nu;m = easy.GetNum();   // 컴파일 에러 발생 !!
    }
}
```
- `const 참조자`를 이용해서는 `const 함수`만 호출이 가능

***const 선언을 많이 사용해서 코드의 안정성을 높이자 !!***

## 04-2 캡슐화(Encapsulation)

정보은닉과 캡슐화는 객체지향 기반의 클래스 설계에서 가장 기본이면서 중요한 원칙들이다.
캡슐화 : 연관된 데이터와 함수를 논리적으로 묶어놓은 것

**콘택600에 숨겨져 있는 캡슐화와 캡슐화의 중요성**

콘택600이 제공하는 기능 : 재채기, 콧물, 코막힘 완화<br>
만약 재채기용 캡슐, 콧물용 캡슐, 코막힘용 캡슐로 나눠져 있다면??
-> 캡슐화가 성립되지 않는 상황
콘택600은 코감기의 강력한 처방이라는 하나의 목적 하에 둘 이상의 기능이 모여서 하나의 목적을 달성하고 있다.
-> 캡슐화가 되어있는 상황

코감기에 걸렸을 때 세가지 캡슐을 다 먹어야 한다.
만약 복용 순서가 정해져 있다면? 잘못 먹었을 때 부작용 초래

결론 : 캡슐화가 무너지면 객체의 활용이 매우 어려워지고, 클래스의 상호관계가 복잡해지기 때문에 이는 프로그램 전체의 복잡도를 높이는 결과로 이어진다.

**그럼 제대로 캡슐화하려면 기침, 몸살, 두통까지 넣어야 하지 않나요?**
캡슐화는 어려운 개념이다. 왜냐하면 <u>캡슐화의 범위를 결정</u>하는 일이 쉽지 않기 때문이다.

- 참고) 캡슐화에는 정보은닉이 기본적으로 포함된다.
  - 캡슐화는 감싸는 개념이다. 이왕이면 멤버변수가 보이지 않게 정보를 은닉해서 감싸는 것이 좋다.

**문제 04-2 [다양한 클래스의 정의]**

```c++
class Point
{
private:
    int xpos, ypos;
public:
    void Init(int x, int y){
        xpos=x;
        ypos=y;
    }
    void ShowPointInfo() const{
        cout << "[" << xpos << ", " << ypos << "]" << endl;
    }
};

class Circle{
private:
    Point p;
    int radius;
public:
    void Init(int x, int y, int _rad){
        p.Init(x, y);
        radius = _red;
    }
    void ShowCircleInfo() const {
        cout << "radius : " << radius << endl;
        cout << p.ShowPointInfo();
    }
};

class Ring{
private:
    Circle inner;
    Circle outter;
public:
    void Init(int ix, int iy, int ir, int ox, int oy, int or){
        inner.Init(ix, iy, ir);
        outter.Init(ox, oy, or);
    }
    void ShowRingInfo() const {
        cout << "Inner Circle Info..." << endl;
        inner.ShowCircleInfo();
        cout << "Outter Circle Info..." << endl;
        outter.ShowCircleInfo();
    }
}
```

- Ring 클래스, Circle 클래스, Point 클래스 모두 자신의 정보를 출력하기 위한 함수를 멤버에 포함시켜서 캡슐화

## 04-3 생성자(Constructor)와 소멸자(Destructor)

`생성자`를 이용하면 객체도 생성과 동시에 초기화할 수 있다.

**생성자의 이해**

생성자 
- 클래스의 이름과 함수의 이름이 동일
- 반환형이 선언되어 있지 않으며 실제로도 반환하지 않음
- 객체 생성 시 딱 한 번 호출
- 함수의 일종이니 오버로딩 가능
- 매개변수에 디폴트 값을 설정 가능

```c++
SimpleClass(){
    num1=0;
    num2=0;
}
```

```c++
SimpleClass sc1();  // XXX
SimpleClass sc1;    // O
SimpleClass * ptr1 = new SimpleClass;   // O
SimpleClass * ptr1 = new SimpleClass;   // O
```
- 위의 생성자를 이용해 객체를 생성할 때 `SimpleClass sc1()` 형태의 문장은 안 됨

```c++
int main(){
    SimpleClass sc1();  // 함수의 원형 선언
    SimpleClass mysc = sc1();
}

SimpleClass sc1()
{
    SimpleClass sc(20, 30);
    return sc;
}
```

- 함수의 원형을 함수 내에 지역적으로도 선언 가능
    - 컴파일러가 객체생성문인지 함수의 원형선언인지 구분할 수 없음
- 함수의 원형선언에만 사용하기로 약속

**멤버 이니셜라이저(Member Initializer)를 이용한 멤버 초기화**

```c++
class Rectagle{
private:
    Point upLeft;
    Point lowRight;
public:
    Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
        : upLeft(x1, y1), lowRight(x2, y2)
        {
            // empty
        }
}
```

`: upLeft(x1, y1), lowRight(x2, y2)`r가 멤버 이니셜라이저
- 객체 upLeft 생성과정에서 x1과 y1을 인자로 전달받는 생성자를 호출하라

*멤버변수로 선언된 객체의 생성자 호출에 활용*

---

C++의 객체 생성 과정
1. 메모리 공간의 할당
2. 이니셜라이저를 이용한 멤버변수(객체)의 초기화(선택적 존재)
3. 생성자의 몸체부분 실행

**멤버 이니셜라이저를 이용한 변수 및 const 상수(변수) 초기화**

멤버 이니셜라이저는 객체가 아닌 멤버의 초기화에도 사용 

```c++
class Simple{
private:
    int num1;
    int num2;
public:
    Simple(int n1, int n2) : num1(n1){
        num2 = n2;
    }
}
```

- 멤버변수 초기화 방법 : 생성자 몸체에서 초기화, 이니셜라이저
  - 일반적으로 이니셜라이저 선호
    - 초기화의 대상을 명확히 인식할 수 있다.
    - 성능에 약간의 이점이 있다.

    ```c++
    num1(n1)
    ```
    이 문장은 아래 문장에 비유할 수 있다.

    ```c++
    int num1 = n1;
    ```
    - ***이니셜라이저를 통해서 초기화되는 멤버는 <u>선언과 동시에 초기화</u>가 이뤄지는 것과 같은 유형의 바이너리 코드를 구성***

    ```c++
    num2 = n2;
    ```
    이 문장은 아래 두 문장에 비유할 수 있다.

    ```c++
    int num2;
    num2 = n2;
    ```
    - 생성자의 몸체부분에서 초기화하면 선언과 초기화를 각각 별도의 문장에서 진행하는 바이너리 코드 생성

그러면
*const 멤버변수도 이니셜라이저를 이용하면 초기화가 가능하다!*

```c++
class FruitSeller{
private:
    const int APPLE_PRICE;
public:
    FruitSeller(int price, int num, int money)
        : APPLE_PRICE(price), numOfApples(num), myMoney(money)
    {}
}
```

- 참고) 
  - const 변수와 const 상수는 같은 의미로 상용된다.

**이니셜라이저의 이러한 특징은 멤버변수로 참조자를 선언할 수 있게 합니다.**
const 변수와 마찬가지로 `참조자`도 선언과 동시에 초기화가 이뤄져야 한다.

```c++
class BBB
{
private:
    AAA &ref;
    const int &num;
public:
    BBB(AAA &r, const int &n)
        : ref(r), num(n)
    {}
}
```

