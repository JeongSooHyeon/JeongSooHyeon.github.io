---
title:  "[뇌를 자극하는 C++ STL] Chapter08_알고리즘"

categories:
  - STL
tags:
  - [Programming, Cpp, STL]

toc: true
toc_sticky: true
 
date: 2023-06-21
last_modified_at: 2023-06-19
---
<br>

## Section01 : 원소를 수정하지 않는 알고리즘

원소를 수정하지 않는 알고리즘(nonmodifying algorithms)은 원소의 순서나 원소의 값을 변경하지 않고 원소를 읽기만 하는 알고리즘

**adjacent_find()**

```c++
iter = adjacent_find(v.begin(), v.end());

if(iter != v.end())
cout << *iter << endl;
```

- `adjacent_find()` : 현재 원소와 다음 원소가 같아지는 첫 원소의 반복자 반환
- 같은 원소가 없으면 구간의 끝 반복자 반환

- 찾기 관련 알고리즘은 찾는 원소를 발견하지 못하면 찾는 구간의 끝 반복자 반환
  - 컨테이너의 끝 표시(past-the-end) 반복자가 아님

**adjacent_find() 알고리즘의 반환 반복자**

```c++
iter_b = v.begin();
iter_e = v.end();

// 구간 [iter_b, iter_e)의 순차열
// 찾는 원소가 없어 iter는 구간의 끝인 iter_e 반환
iter = adjacent_find(iter_b, iter_e);

if(iter != iter_e)  // 찾은 원소가 없는지 확인 <<맞는 표현>>
    cout << *iter;
    
if(iter != v.end()) // 찾은 원소가 없는지 확인 <<틀린 표현>>
    cout << *iter;
```

**adjacent_find() 조건자 버전**

```c++
// 이항 조건자
bool Pred(int a, int b){
    return abs(b-a) > 10;   // abs() 절댓값
}
int main(){
    iter = adjacent_find(v.begin(), v.end(), Pred);

    if(iter != v.end())
        cout << *iter;
}
```

- `adjacent_find(b,e,f)` : 특정 조건에 따라 인접한지 찾고자 할 때 사용
  - f는 이항 조건자, f(*p, *(p+1))가 참인 첫 원소의 반복자 반환

**count()**
```c++
// 구간 [v.begin(), v.end()) 에서 30 원소의 개수를 반환
int n = count(v.begin(), v.end(), 30);
```

- `count()` : 순차열에서 원소의 개수를 구함

**조건자 버전 count_if()**
```c++
bool Pred(int n){
  return 25 < n;
}
int main(){
  int n = count_if(v.begin(), v.end(), Pred);
}
```

- `count_if(b,e,f)` : 조건에 맞는 원소의 개수
- f는 단항 조건자, 반복자 p에 대해 f(*p)가 참인 원소의 개수 반환

**equal()**
```c++
// 구간 [v1.begin(), v1.end)와 구간 [v2.begin(), v2.begin()+3)을 비교
if(equal(v1.begin(), v1.end(), v2.begin()))
  cout << "두 순차열은 같습니다.";
```

- `equal()` : 두 순차열의 원소가 모드 같은지 판단
- equal(b,e,b2) : 구간 [b, e)의 순차열과 구간 [b2, b2+(e-b)) 순차열이 같은지 판단
- 두 개의 순차열을 필요로하는 대부분의 알고리즘은 두 순차열의 길이가 같을 때 동작
  - 두 번째 순차열을 시작 반복자만 필요

**조건자 equal()**
```c++
bool Pred(int left, int right){
  return abs(right-left) < 5;
}
int main(){
  if(equal(v1.begin(), v1.end(), v2.begin(), Pred))
    cout << "두 순차열은 같습니다.";
}
```

- 조건에 따라 두 순차열이 같은지 비교
- f는 이항 조건자, f(*p, *q)가 모두 참이면 참 반환

**find(), find_if()**
```c++
bool Pred(int n){
  return 35 < n;
}
int main(){
  iter = find(v.begin(), v.end(), 20);
  if(iter != v.end())
    cout << *iter << "을 찾다";
  
  iter = find_if(v.begin(), v.end(), Pred);
  if(iter != v.end())
    cout << "순차열에서 35보다 큰 첫 번재 원소 : " << *iter;
}
```

- `find()` : 특정 원소를 갖는 첫 원소의 반복자 반환
- `find_if()` : 조건에 따라 원소를 찾는 알고리즘, 단항 조건자 f(*p)가 참인 첫 원소의 반복자 반환

**find_end(), search()**

```c++
// 구간 [v1.begin(), v1.end())의 순차열에 구간 [v2.begin(), v2.end())의 순차열이 일치하는지 판단
iter = find_end(v1.begin(), v1.end(), v2.begin(), v2.end());
if(iter != v1.end())
  // 일치하는 마지막 순차열의 첫 원소의 반복자 iter
  cout << *iter;
```

- `find_end()` : 일치하는 순차열이 여러 개라면 마지막 순차열의 반복자 반환
- `search()` : 첫 번째 순차열의 반복자를 반환

**조건자 버전 find_end()**
```c++
bool Pred(int left, int right){
  return left <= right;
}
int main(){
  iter = find_end(v1.begin(), v1.end(), v2.begin(), v2.end(), Pred);
  if(iter != v1.end())
    cout << *iter;
}
```

- 두 순차열을 Pred(*p, *q) 비교
- [v2.begin(), v2.end())의 순차열이 [v1.begin(), v1.end())의 순차열의 원소보다 모두 크거나 같은 순차열 구간

**find_first_of()**
```c++
iter = find_first_of(v1.begin(), v1.end(), v2.begin(), v2.end());
if(iter != v1.end())
  cout << *iter;
```

- `find_first_of()` : 두 순차열을 비교하여 모든 원소 중 <u>같은 원소가 하나라도 발견</u>되면 발견된 첫 원소의 반복자 반환

**조건자 find_first_of()**

```c++
bool Pred(int left, int right){
  return left > right;
}
int main(){
  // v1의 순차열에서 v2의 원소보다 큰 첫 원소의 반복자 반환
  iter = find_first_of(v1.begin(), v1.end(), v2.begin(), v2.end(), Pred);
}
```

- 순차열 v1에서 v2의 순차열 원소보다 큰 첫 원소의 반복자

**for_each()**
```c++
void Print(int n){
  cout << n << " ";
}
int main(){
  for_each(v.begin(), v.begin()+2, Print);
  for_each(v.begin(), v.begin()+4, Print);
  // [v.begin(), v.end())구간의 원소 출력
  for_each(v.begin(), v.end(), Print);
}
```

- `for_each()` : 원소를 수정하지 않는 알고리즘, 원소를 수정하는 알고리즘 두 부류에 모두 포함
- `for_each(b,e,f)` : 구간 [b,e)의 반복자가 p라면 f(*p)를 호출

**for_each() 알고리즘과 반복자**
```c++
class PrintFunctor{
  char fmt;
public:
  explicit PrintFunctor(char c = ' ') : fmt(c) { }
  void operator()(int n) const{
    cout << n << fmt;
  }
};
int main(){
  for_each(v.begin(), v.end(), PrintFunctor()); // 원소 구분을 ' '로 
  for_each(v.begin(), v.end(), PrintFunctor(',')); // 원소 구분을 ','로 
  for_each(v.begin(), v.end(), PrintFunctor('\n')); // 원소 구분을 '\n'로 
}
```

- for_each() 알고리즘의 함수류를 `함수자`로 하면 다양한 출력 패턴을 구현할 수 있다.
- 함수자는 객체이므로 <u>상태 변수를 사용하여 부가적인 정보를 전달하고 변경</u>할 수 있기 때문

**lexicographical_compare()**
```c++
if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end()))
  cout << "v1 < v2" << endl;
else
  cout << "v1 >= v2" << endl;
```

- `lexicographical_compare()` : 문자열 비교처럼 순차열의 사전순 비교(less : <)
- lexicographical_compare(b,e,b2,e2) : 순차열 [b,e)와 [b2,e2)의 모든 원소를 문자열처럼 비교(less : <)하여 참과 거짓 반환

**조건자 버전 lexicographical_conmpare()**

```c++
template<typename T>
struct Less{
  bool operator()(const T& left, const T& right) const{
    return left < right;
  }
};
int main(){
  if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end(), less<int>()))
    cout << "기준 less v1과 v2의 비교 : true";
    
  if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end(), greater<int>()))
    cout << "기준 greater v1과 v2의 비교 : true"

  if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end(), Less<int>()))
    cout << "사용자 기준 Less v1과 v2의 비교 : true"
}
```

- 기본 비교 기준 less(<)

**max(), min()**
```c++
bool XCompare(const Point& left, const Point& right){
  return left.GetX() < right.GetX();
}
bool YCompare(const Point& left, const Point& right){
  return left.GetY() < right.GetY();
}

int main(){
  int a = 10, b = 20;
  int r;

  r = max(a, b);
  r = min(a, b);

  Point pt1(5, 8), pt2(3, 9);
  Point pt3;

  pt3 = max(pt1, pt2, XCompare);
  pt3 = min(pt1, pt2, YCompare);
}
```

- `XCompare, YCompare` : pt1과 pt2는 Point 객체로 비교 연산자가 없어 크기 비교 불가능, 따라서 이항 조건자를 사용하여 값 비교
- 조건자가 참인 Point 객체 반환

**max_element(), min_element()**
```c++
bool Compare(const Point& left, const Point& right){
  if(left.GetX() < right.GetX())
    return true;
  else if(left.GetX() > right.GetX())
    return false;
  else
    return left.GetY() < right.GetY();
}

int main(){
  iter = max_element(v.begin(), v.end());
  cout << *iter;

  iter = min_element(v.begin(), v.end());
  cout << *iter;

  iter = max_element(v.begin(), v.end(), Compare);
  cout << iter->Print();  // 반복자가 가리키는 객체의 멤버는 -> 연산자로 접근
  cout << (*iter).Print();  // 위와 같음
}
```

- `max_element(b,e), max_element(b,e,f)` : 구간 [b,e)에서 가장 큰 원소의 반복자 반환
- f는 비교 기준으로 사용될 이항 조건자

**mismatch()**
```c++
bool Pred(int left, int right){
  return abs(right-left) <= 5;
}
int main(){
  pair<vector<int>::iterator, vector<int>::iterator> iter_pair;
  iter_pair = mismatch(v1.begin(), v1.end(), v2.begin());

  cout << "v1 : " << *iter_pair.first << "v2 : " << *iter_pair.second;

  iter_pair = mismatch(v1.begin(), v1.end(), v2.begin(), Pred);
}
```

- `mismatch()` : 두 순차열을 비교하여 원소의 값이 서로 다른 위치를 찾음
- 원소 값이 서로 다른 첫 원소의 반복자 쌍 반환

- `mismatch(b,e,b2,f)` : f는 이항 조건자, !f(*p, *q)가 참인 첫 원소의 반복자 반환

**serach()**
```c++
iter = search(v1.begin(), v1.end(), v2.begin(), v2.end());
if(iter != v1.end())
  cout << *iter;
```

- `search()` 알고리즘이 find_end()와 다른 점은 일치하는 순차열이 여러 개라면 find_end()는 마지막 순차열의 반복자 반환, search()는 <u>첫 번재 순차열의 반복자를 반환</u>

**search_n()**
```c++
bool Pred(int left, int right){
  return abs(right-left) <= 5;
}

int main(){
  iter = search_n(v.begin(), v.end(), 3, 30); // 30이 3번 이상 연속한 위치
  if(iter != v.end())
    cout << *iter;

  iter = search_n(v.begin(), v.end(), 3, 30, Pred); // 30과의 차가 5이하인 원소가 3번 이상 연속한 첫 원소의 반복자
  if(iter != v.end())
    cout << *iter;
}
```

- `search_n()` : 순차열에서 원소의 값이 n번 연속하게 반복되는지 찾기
- search_n(b,e,n,x) 구간 [b,e)의 순차열에서 원소 x가 n번 연속한 첫 원소의 반복자를 반환

- `search_n(b,e,n,x,f)` : 조건자 f(*p,x)가 참인 값이 n개 연속한 첫 원소의 반복자 반환

## Section02 : 원소를 수정하는 알고리즘

원소를 수정하는 알고리즘(modifying algorithms) : 원소의 값은 변경, 목적지 순차열로 원소를 복사하는 알고리즘

**copy()**
```c++
// 구간 [v1.begin(), v1.end())의 모든 원소를 [v2.begin(), iter)의 순차열로 복사
iter = copy(v1.begin(), v1.end(), v2.begin());
cout << "v2 마지막 원소 : " << *(iter-1);
```

- `copy()` : 순차열에서 다른 순차열로 원소를 복사, 목적지 끝 반복자 반환하므로 목적지 순차열은 [v2.begin(), iter)가 됨
- 두 가지 모드의 복사 동작 : 덮어쓰기(overWrite) 모드, 삽입(insert) 모드
  - 기본 동작은 덮어쓰기, 반복자 어댑터(insert iterator) 등을 사용하여 알고리즘을 삽입 모드로 동작하게 할 수 있음
- 덮어쓰기 모드로 복사 동작을 수행 시 [v2.begin(), v2.end())의 순차열은 구간 [v1.begin(), v1.end()) 순차열 이상의 원소를 가져야 함

**copy_backward()**
```c++
iter = copy_backward(v1.begin(), v1.end(), v2.end());
```

- `copy_backward()` : 원소의 복사를 순차열의 마지막 원소부터 복사
- 목적지 시작 반복자를 반환하므로 목적지 순차열은 [iter, v2.end())가 됨

**fill(), fill_n()**
```c++
fill(v.begin(), v.end(), 0);

fill_n(v.begin(), 3, 55);
```

- 순차열을 특정 값으로 채우기
- `fill(b,e,x)` : 구간 [b,3)의 원소를 x로 채움
- `fill(b,n,x)` : 구간 [b,b+n)의 원소를 x로 채움

**for_each() 알고리즘을 사용한 원소 수정**
```c++
// 출력 매개변수로 사용하기 위해 &(레퍼런스) 사용
void Func(int& r){
  r += 5;
}

int main(){
  for_each(v.begin(), v.end(), Func);
}
```

- for_each(b,e,f) : 모든 원소에 f(*p)를 적용, f는 함수자
- 사용자 함수의 매개변수는 출력 매개변수로 사용되어야 하므로 꼭 &(래퍼런스)를 사용
- 함수류를 모든 원소에 적용하는 알고리즘은 for_each()와 transform()이 있으며 for_each()는 출력 매개변수(out parameter)를 사용하고, transform()은 함수의 반환 값을 사용하여 사용자의 동작(함수)을 원소에 적용