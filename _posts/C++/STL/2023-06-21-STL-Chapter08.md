---
title:  "[뇌를 자극하는 C++ STL] Chapter08_알고리즘"

categories:
  - STL
tags:
  - [Programming, Cpp, STL]

toc: true
toc_sticky: true
 
date: 2023-06-21
last_modified_at: 2023-06-19
---
<br>

## Section01 : 원소를 수정하지 않는 알고리즘

원소를 수정하지 않는 알고리즘(nonmodifying algorithms)은 원소의 순서나 원소의 값을 변경하지 않고 원소를 읽기만 하는 알고리즘

**adjacent_find()**

```c++
iter = adjacent_find(v.begin(), v.end());

if(iter != v.end())
cout << *iter << endl;
```

- `adjacent_find()` : 현재 원소와 다음 원소가 같아지는 첫 원소의 반복자 반환
- 같은 원소가 없으면 구간의 끝 반복자 반환

- 찾기 관련 알고리즘은 찾는 원소를 발견하지 못하면 찾는 구간의 끝 반복자 반환
  - 컨테이너의 끝 표시(past-the-end) 반복자가 아님

**adjacent_find() 알고리즘의 반환 반복자**

```c++
iter_b = v.begin();
iter_e = v.end();

// 구간 [iter_b, iter_e)의 순차열
// 찾는 원소가 없어 iter는 구간의 끝인 iter_e 반환
iter = adjacent_find(iter_b, iter_e);

if(iter != iter_e)  // 찾은 원소가 없는지 확인 <<맞는 표현>>
    cout << *iter;
    
if(iter != v.end()) // 찾은 원소가 없는지 확인 <<틀린 표현>>
    cout << *iter;
```

**adjacent_find() 조건자 버전**

```c++
// 이항 조건자
bool Pred(int a, int b){
    return abs(b-a) > 10;   // abs() 절댓값
}
int main(){
    iter = adjacent_find(v.begin(), v.end(), Pred);

    if(iter != v.end())
        cout << *iter;
}
```

- `adjacent_find(b,e,f)` : 특정 조건에 따라 인접한지 찾고자 할 때 사용
  - f는 이항 조건자, f(*p, *(p+1))가 참인 첫 원소의 반복자 반환

**count()**
```c++
// 구간 [v.begin(), v.end()) 에서 30 원소의 개수를 반환
int n = count(v.begin(), v.end(), 30);
```

- `count()` : 순차열에서 원소의 개수를 구함

**조건자 버전 count_if()**
```c++
bool Pred(int n){
  return 25 < n;
}
int main(){
  int n = count_if(v.begin(), v.end(), Pred);
}
```

- `count_if(b,e,f)` : 조건에 맞는 원소의 개수
- f는 단항 조건자, 반복자 p에 대해 f(*p)가 참인 원소의 개수 반환

**equal()**
```c++
// 구간 [v1.begin(), v1.end)와 구간 [v2.begin(), v2.begin()+3)을 비교
if(equal(v1.begin(), v1.end(), v2.begin()))
  cout << "두 순차열은 같습니다.";
```

- `equal()` : 두 순차열의 원소가 모드 같은지 판단
- equal(b,e,b2) : 구간 [b, e)의 순차열과 구간 [b2, b2+(e-b)) 순차열이 같은지 판단
- 두 개의 순차열을 필요로하는 대부분의 알고리즘은 두 순차열의 길이가 같을 때 동작
  - 두 번째 순차열을 시작 반복자만 필요

**조건자 equal()**
```c++
bool Pred(int left, int right){
  return abs(right-left) < 5;
}
int main(){
  if(equal(v1.begin(), v1.end(), v2.begin(), Pred))
    cout << "두 순차열은 같습니다.";
}
```

- 조건에 따라 두 순차열이 같은지 비교
- f는 이항 조건자, f(*p, *q)가 모두 참이면 참 반환

**find(), find_if()**
```c++
bool Pred(int n){
  return 35 < n;
}
int main(){
  iter = find(v.begin(), v.end(), 20);
  if(iter != v.end())
    cout << *iter << "을 찾다";
  
  iter = find_if(v.begin(), v.end(), Pred);
  if(iter != v.end())
    cout << "순차열에서 35보다 큰 첫 번재 원소 : " << *iter;
}
```

- `find()` : 특정 원소를 갖는 첫 원소의 반복자 반환
- `find_if()` : 조건에 따라 원소를 찾는 알고리즘, 단항 조건자 f(*p)가 참인 첫 원소의 반복자 반환

**find_end(), search()**

```c++
// 구간 [v1.begin(), v1.end())의 순차열에 구간 [v2.begin(), v2.end())의 순차열이 일치하는지 판단
iter = find_end(v1.begin(), v1.end(), v2.begin(), v2.end());
if(iter != v1.end())
  // 일치하는 마지막 순차열의 첫 원소의 반복자 iter
  cout << *iter;
```

- `find_end()` : 일치하는 순차열이 여러 개라면 마지막 순차열의 반복자 반환
- `search()` : 첫 번째 순차열의 반복자를 반환

**조건자 버전 find_end()**
```c++
bool Pred(int left, int right){
  return left <= right;
}
int main(){
  iter = find_end(v1.begin(), v1.end(), v2.begin(), v2.end(), Pred);
  if(iter != v1.end())
    cout << *iter;
}
```

- 두 순차열을 Pred(*p, *q) 비교
- [v2.begin(), v2.end())의 순차열이 [v1.begin(), v1.end())의 순차열의 원소보다 모두 크거나 같은 순차열 구간

**find_first_of()**
```c++
iter = find_first_of(v1.begin(), v1.end(), v2.begin(), v2.end());
if(iter != v1.end())
  cout << *iter;
```

- `find_first_of()` : 두 순차열을 비교하여 모든 원소 중 <u>같은 원소가 하나라도 발견</u>되면 발견된 첫 원소의 반복자 반환

**조건자 find_first_of()**

```c++
bool Pred(int left, int right){
  return left > right;
}
int main(){
  // v1의 순차열에서 v2의 원소보다 큰 첫 원소의 반복자 반환
  iter = find_first_of(v1.begin(), v1.end(), v2.begin(), v2.end(), Pred);
}
```

- 순차열 v1에서 v2의 순차열 원소보다 큰 첫 원소의 반복자

**for_each()**
```c++
void Print(int n){
  cout << n << " ";
}
int main(){
  for_each(v.begin(), v.begin()+2, Print);
  for_each(v.begin(), v.begin()+4, Print);
  // [v.begin(), v.end())구간의 원소 출력
  for_each(v.begin(), v.end(), Print);
}
```

- `for_each()` : 원소를 수정하지 않는 알고리즘, 원소를 수정하는 알고리즘 두 부류에 모두 포함
- `for_each(b,e,f)` : 구간 [b,e)의 반복자가 p라면 f(*p)를 호출

**for_each() 알고리즘과 반복자**
```c++
class PrintFunctor{
  char fmt;
public:
  explicit PrintFunctor(char c = ' ') : fmt(c) { }
  void operator()(int n) const{
    cout << n << fmt;
  }
};
int main(){
  for_each(v.begin(), v.end(), PrintFunctor()); // 원소 구분을 ' '로 
  for_each(v.begin(), v.end(), PrintFunctor(',')); // 원소 구분을 ','로 
  for_each(v.begin(), v.end(), PrintFunctor('\n')); // 원소 구분을 '\n'로 
}
```

- for_each() 알고리즘의 함수류를 `함수자`로 하면 다양한 출력 패턴을 구현할 수 있다.
- 함수자는 객체이므로 <u>상태 변수를 사용하여 부가적인 정보를 전달하고 변경</u>할 수 있기 때문

**lexicographical_compare()**
```c++
if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end()))
  cout << "v1 < v2" << endl;
else
  cout << "v1 >= v2" << endl;
```

- `lexicographical_compare()` : 문자열 비교처럼 순차열의 사전순 비교(less : <)
- lexicographical_compare(b,e,b2,e2) : 순차열 [b,e)와 [b2,e2)의 모든 원소를 문자열처럼 비교(less : <)하여 참과 거짓 반환

**조건자 버전 lexicographical_conmpare()**

```c++
template<typename T>
struct Less{
  bool operator()(const T& left, const T& right) const{
    return left < right;
  }
};
int main(){
  if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end(), less<int>()))
    cout << "기준 less v1과 v2의 비교 : true";
    
  if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end(), greater<int>()))
    cout << "기준 greater v1과 v2의 비교 : true"

  if(lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end(), Less<int>()))
    cout << "사용자 기준 Less v1과 v2의 비교 : true"
}
```

- 기본 비교 기준 less(<)

**max(), min()**
```c++
bool XCompare(const Point& left, const Point& right){
  return left.GetX() < right.GetX();
}
bool YCompare(const Point& left, const Point& right){
  return left.GetY() < right.GetY();
}

int main(){
  int a = 10, b = 20;
  int r;

  r = max(a, b);
  r = min(a, b);

  Point pt1(5, 8), pt2(3, 9);
  Point pt3;

  pt3 = max(pt1, pt2, XCompare);
  pt3 = min(pt1, pt2, YCompare);
}
```

- `XCompare, YCompare` : pt1과 pt2는 Point 객체로 비교 연산자가 없어 크기 비교 불가능, 따라서 이항 조건자를 사용하여 값 비교
- 조건자가 참인 Point 객체 반환

**max_element(), min_element()**
```c++
bool Compare(const Point& left, const Point& right){
  if(left.GetX() < right.GetX())
    return true;
  else if(left.GetX() > right.GetX())
    return false;
  else
    return left.GetY() < right.GetY();
}

int main(){
  iter = max_element(v.begin(), v.end());
  cout << *iter;

  iter = min_element(v.begin(), v.end());
  cout << *iter;

  iter = max_element(v.begin(), v.end(), Compare);
  cout << iter->Print();  // 반복자가 가리키는 객체의 멤버는 -> 연산자로 접근
  cout << (*iter).Print();  // 위와 같음
}
```

- `max_element(b,e), max_element(b,e,f)` : 구간 [b,e)에서 가장 큰 원소의 반복자 반환
- f는 비교 기준으로 사용될 이항 조건자

**mismatch()**
```c++
bool Pred(int left, int right){
  return abs(right-left) <= 5;
}
int main(){
  pair<vector<int>::iterator, vector<int>::iterator> iter_pair;
  iter_pair = mismatch(v1.begin(), v1.end(), v2.begin());

  cout << "v1 : " << *iter_pair.first << "v2 : " << *iter_pair.second;

  iter_pair = mismatch(v1.begin(), v1.end(), v2.begin(), Pred);
}
```

- `mismatch()` : 두 순차열을 비교하여 원소의 값이 서로 다른 위치를 찾음
- 원소 값이 서로 다른 첫 원소의 반복자 쌍 반환

- `mismatch(b,e,b2,f)` : f는 이항 조건자, !f(*p, *q)가 참인 첫 원소의 반복자 반환

**serach()**
```c++
iter = search(v1.begin(), v1.end(), v2.begin(), v2.end());
if(iter != v1.end())
  cout << *iter;
```

- `search()` 알고리즘이 find_end()와 다른 점은 일치하는 순차열이 여러 개라면 find_end()는 마지막 순차열의 반복자 반환, search()는 <u>첫 번재 순차열의 반복자를 반환</u>

**search_n()**
```c++
bool Pred(int left, int right){
  return abs(right-left) <= 5;
}

int main(){
  iter = search_n(v.begin(), v.end(), 3, 30); // 30이 3번 이상 연속한 위치
  if(iter != v.end())
    cout << *iter;

  iter = search_n(v.begin(), v.end(), 3, 30, Pred); // 30과의 차가 5이하인 원소가 3번 이상 연속한 첫 원소의 반복자
  if(iter != v.end())
    cout << *iter;
}
```

- `search_n()` : 순차열에서 원소의 값이 n번 연속하게 반복되는지 찾기
- search_n(b,e,n,x) 구간 [b,e)의 순차열에서 원소 x가 n번 연속한 첫 원소의 반복자를 반환

- `search_n(b,e,n,x,f)` : 조건자 f(*p,x)가 참인 값이 n개 연속한 첫 원소의 반복자 반환

## Section02 : 원소를 수정하는 알고리즘

원소를 수정하는 알고리즘(modifying algorithms) : 원소의 값은 변경, 목적지 순차열로 원소를 복사하는 알고리즘

**copy()**
```c++
// 구간 [v1.begin(), v1.end())의 모든 원소를 [v2.begin(), iter)의 순차열로 복사
iter = copy(v1.begin(), v1.end(), v2.begin());
cout << "v2 마지막 원소 : " << *(iter-1);
```

- `copy()` : 순차열에서 다른 순차열로 원소를 복사, 목적지 끝 반복자 반환하므로 목적지 순차열은 [v2.begin(), iter)가 됨
- 두 가지 모드의 복사 동작 : 덮어쓰기(overWrite) 모드, 삽입(insert) 모드
  - 기본 동작은 덮어쓰기, 반복자 어댑터(insert iterator) 등을 사용하여 알고리즘을 삽입 모드로 동작하게 할 수 있음
- 덮어쓰기 모드로 복사 동작을 수행 시 [v2.begin(), v2.end())의 순차열은 구간 [v1.begin(), v1.end()) 순차열 이상의 원소를 가져야 함

**copy_backward()**
```c++
iter = copy_backward(v1.begin(), v1.end(), v2.end());
```

- `copy_backward()` : 원소의 복사를 순차열의 마지막 원소부터 복사
- 목적지 시작 반복자를 반환하므로 목적지 순차열은 [iter, v2.end())가 됨

**fill(), fill_n()**
```c++
fill(v.begin(), v.end(), 0);

fill_n(v.begin(), 3, 55);
```

- 순차열을 특정 값으로 채우기
- `fill(b,e,x)` : 구간 [b,3)의 원소를 x로 채움
- `fill(b,n,x)` : 구간 [b,b+n)의 원소를 x로 채움

**for_each() 알고리즘을 사용한 원소 수정**
```c++
// 출력 매개변수로 사용하기 위해 &(레퍼런스) 사용
void Func(int& r){
  r += 5;
}

int main(){
  for_each(v.begin(), v.end(), Func);
}
```

- for_each(b,e,f) : 모든 원소에 f(*p)를 적용, f는 함수자
- 사용자 함수의 매개변수는 출력 매개변수로 사용되어야 하므로 꼭 &(래퍼런스)를 사용
- 함수류를 모든 원소에 적용하는 알고리즘은 for_each()와 transform()이 있으며 for_each()는 출력 매개변수(out parameter)를 사용하고, transform()은 함수의 반환 값을 사용하여 사용자의 동작(함수)을 원소에 적용

참고) 출력 매개변수
함수에서 호출자에게 다시 전달되는 정보

**for_each() 함수자 사용**
```c++
class Accumulation{
  int total;
public:
  explicit Accumulation(int init=0):total(init){}
  void operator()(int& r){
    total += r;
    r = total;
  }
};

int main(){
  // [v.begin(), v.end()) 모든 원소를 초깃값 0부터 시작해 *p += *(p-1)를 적용
  for_each(v.begin(), v.end(), Accumulation(0));
}
```

- 사용자 함수류를 함수자(함수 객체)로 구현하면 객체는 상태 변수를 가질 수 있으므로 함수를 사용하는 것보다 더 다양한 작업을 순차열에 적용할 수 있다.
- total 상태 변수를 사용하여 이전 원소의 누적 값을 저장하고 현재 원소에 이전 원소와의 누적을 적용

**generate()**
```c++
class Integer{
  int data;
public:
  explicit Integer(int d=0):data(d){}
  int operator()(){
    return data++;
  };

  int main(){
    generate(v.begin(), v.end(), Integer(1));
    generate_n(v.begin(), 3, Integer(1));
  }
}
```

- `generate()` : 순차열의 모든 원소를 단순한 동작의 값으로 수정
- generate(b,e,f) : [b,e)의 모든 원소를 f()로 채움
- generate_n(b,n,f) : [b,b+n)의 모든 원소를 f()로 채움
- for_each(), transform() 알고리즘과의 차이점 : 함수자의 매개변수로 순차열의 원소를 전달받지 않으므로, 원소가 가지고 있는 원값을 활용할 수 없고, 단순히 일정한 값으로 채울 뿐임

**swap(), iter_swap()**
```c++
int a=10, b=20;
swap(a, b);

vector<int>::iterator p = v.begin();
vector<int>::iterator q = v.begin()+1;
iter_swap(p, q);
```

- `swap()` : 단순히 값을 교환
- `iter_swap()` : 반복자가 가리키는 값을 교환

**merge()**
```c++
iter_end = merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());
```

- `merge()` : <u>정렬된 두 순차열</u>을 하나의 정렬된 순차열로 합병
- 목적지 끝 반복자를 반환, 결론적으로 구간 [v3.begin(), iter_end)로 합병 정렬

**조건자 버전 merge()**
```c++
template<typename>
struct Greater{
  bool operator()(const T& left, const T& right) const{
    return left > right;
  }
};

int main(){
  iter_end = merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin(), Greater<int>());
}
```

- 합병하려는 두 순차열이 특정 정렬 기준에 의해 정렬된 상태일 때 사용
- merge()는 기본적으로 오름차순 정렬 기준(less : <)을 전제로 동작
- f는 이항 조건자

**replace(), replace_if()**
```c++
bool Pred(int n){
  return 30 <= n && n <= 50;
}
int main(){
  replace(v.begin(0, v.end(), 30, 0));

  replace_if(v.begin(), v.end(), Pred, 0);
}
```

- `replace()` : 순차열의 특정 원소를 다른 값으로 수정
- replace(b,e,x,x2) : [b,e)의 x인 원소를 x2로 수정
- `replace_if(b,e,f,x2)` : [b,e)의 원소 중 f(*p)가 참인 원소를 모두 x2로 변경
- f는 단항 조건자

**replace_copy(), replace_copy_if()**
```c++
bool Pred(int n){
  return n <= 30;
}
int main(){
  // 30이하인 원소를 모두 0으로 변환하여 [v2.begin(), iter_end) 순차열에 저장
  iter_end = replace_copy(v1.begin(), v1.end(), v2.begin(), 30, 0);

  // Pred(*p)가 참인 원소를 0으로 수정하여 복사
  iter_end = replace_copy_if(v1.begin(), v1.end(), v3.begin(), Pred, 0);
}
```

- 사용자 조건에 맞는 원소를 수정하여 목적지 순차열로 복사

**swap_range()**
```c++
swap_ranges(v1.begin(), v1.end(), v2.begin());
```

- `swap_range()` : 순차열과 순차열의 모든 원소를 교환

**transform()**
```c++
int Func(int n){
  return n+5;
}
int main(){
  iter_end = transform(v.begin(), v.end(), v.begin(), Func);
}
```
- 순차열의 모든 원소에 사용자의 정책을 반영하려면 일반적으로 for_each(), transform() 알고리즘을 사용, transform() 알고리즘이 for_each()와 다른 것은 원본의 순차열의 변화 없이 목적지의 순차열로 저장한다는 것, 덮어쓰기 동작
- `int Func(int n)` : for_each() 알고리즘과 다르게 반환 타입을 가짐
- transform(b,e,t,f) : f(*p)를 호출하여 반환값을 순차열 [t, t+(e-b))에 저장
- f는 단항 함수류
- 목적지의 끝 반복자 반환

**함수류 적용 transform(b,e,b2,t,f)**
```c++
int Plus(int left, int right){
  return left+right;
}

int main(){
  iter_end = transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), plus<int>());
  iter_end = transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), Plus);
}
```
- f(*p, *q)한 값을 저장


## 원소를 수정하는 알고리즘 끝

- 한 가지 주의점은 이 알고리즘 모두가 `덮어쓰기(overwrite)` 모드로 동작.
  - 그래서 목적지 순차열은 원본 이상의 원소를 가지고 있어야 함
- 삽입(insert) 모드로 동작하려면 `insert_iterator` 사용

## Section03 : 제거 알고리즘

제거 알고리즘(removing algorithms)은 '원소를 수정하는 알고리즘'의 특수한 형태
제거 알고리즘은 원소를 실제로 제거하지 않고 논리적으로 제거(다음 원소로 덮어쓰기)하기 때문에 순차열의 size를 실제로는 변경하지 않음, 실제 size 변경은 컨테이너의 erase() 멤버 함수 이용

**remove()**
```c++
iter_end = remove(v.begin(), v.end(), 30);

// remove 전 v : 10 20 30 40 50
// remove 후 v : 10 20 40 50 50(iter_end)
```

- p = remove(b,e,x) : [b,e)의 순차열에서 x인 원소가 남지 않게 함, 실제 원소를 제거하지 않고 단지 다음 원소를 앞으로 이동, 알고리즘 후의 순차열 [b,p)

**erase()**
```c++
iter_end = remove(v.begin(), v.end(), 30);

v.erase(iter_end, v.end());

// erase 전 v : 10 20 40 50 30(iter_end) 50 
// erase 후 v : 10 20 40 50
```

- 원소를 실제로 제거, 컨테이너의 size까지 변경, 멤버 함수임

**조건자 remove_if()**
```c++
bool Pred(int n){
  return 30<=n && n<=40;
}
int main(){
  iter_end = remove_if(v.begin(), v.end()), Pred)
}
```

- 조건에 따라 원소 제거
- f(*p)가 참인 원소를 논리적으로 제거

**remove_copy()**
```c++
iter_end = remove_copy(v1.begin(), v1.end(), v2.begin(0, 30));
```

- 순차열의 원본을 변경하지 않고 특정 원소를 제거하여 목적지 순차열로 복사
- remove_copy(b,e,t,x) : [b,e) 순차열에서 *p==x인 원소를 제외한 원소를 [t,p)에 복사, 덮어쓰기

**remove_copy_if()**

- 조건자가 참이 아닌 원소만 목적지 순차열에 복사

**unique()**
```c++
iter_end = unique(v.begin(), v.end());

// v : 10 20 30 30 40 40 30 50 
// v : 10 20 30 40 30 50 30 50
```

- 순차열의 인접 원소를 유일하게 만들기
- 정렬한 상태에서 unique() 알고리즘 수행하면 모든 원소를 유일하게 만들 수 있음

**조건자 버전 unique()**
```c++
bool Pred(int left, int right){
  return abs(right-left) < 10;
}
int main(){
  iter_end = unique(v.begin(), v.end(), Pred);
}
```

- p = unique(b,e,f) : [b,e)을 f(*p)가 참인 인접한 원소를 논리적으로 제거

**unique_copy(), 조건자 버전 unique_copy()**

- 인접한 중복 원소를 제거하여 목적지 순차열로 복사