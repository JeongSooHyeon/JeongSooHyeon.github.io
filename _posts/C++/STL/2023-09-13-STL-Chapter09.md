---
title:  "[뇌를 자극하는 C++ STL] Chapter09_STL 함수 객체"

categories:
  - STL
tags:
  - [Programming, Cpp, STL]

toc: true
toc_sticky: true
 
date: 2023-09-13
last_modified_at: 2023-09-15
---
<br>

STL은 다양한 함수 객체를 제공. STL의 함수 객체는 클라이언트가 정의한 동작을 다른 구성 요소에 반영하기 위해 사용. 많은 알고리즘은 STL 함수 객체를 알고리즘의 인자로 받아 유연하게 동작할 수 있게 한다. 함수 객체는 \<functional> 헤더에 정의

## Section01 : 함수 객체의 종류

함수 객체(function object)는 함수자(functor)라는 애칭으로 더 많이 사용되며, operator() 연산자를 오버로딩한 클래스 객체이다.

1. 일반 함수 객체 : 특정 기능을 수행하는 함수 객체
  - 산술 연산 함수 객체 : 산술 연산 기능을 수행(plus, minus, multiplies, divider, modulus, negate)
  - 비교 연산 함수 객체 조건자 : 비교 조건자(equal_to, not_equal_to, less, greater, greater_equal, less_equal)
  - 논리 연산 함수 객체 조건자 : 논리 조건자(logical_and, logical_or, logical_not)
2. 함수 어댑터(function adpator) : 함수류(함수 객체, 함수, 함수 포인터)를 인자로 받아 다른 함수 객체로 변환
  - 바인더(binder) : 이항 함수 객체를 단항 함수 객체로 변환(bind1st, bind2nd)
  - 부정자(negator) : 함수 객체 조건자를 반대로 변환(not1, not2)
  - 함수 포인터 어댑터 : 함수 포인터를 STL이 요구하는 함수 객체로 변환(ptr_fun)
  - 멤버 함수 포인터 어댑터 : 멤버 함수 포인터를 STL이 요구하는 함수 객체로 변환(mem_fun, mem_fum_ref)

여기서 `조건자`는 bool 형식을 반환하는 함수류(함수 객체, 함수, 함수 포인터)이다. 많은 알고리즘에 이런 함수류를 사용자 조건으로 가정하여 알고리즘이 유연하게 동작하도록 한다.

**세 가지 조건자**
```c++
struct LessFunctor{ // 1. 함수 객체 조건자
  bool operator()(int left, int right) const{
    return left < right;
  }
};

bool LessFun(int left, int right){  // 2. 함수 조건자
  return left < right;
}

int main(){
  bool (*LessPtr)(int, int) = LessFunc; // 3. 함수 포인터 조건자
  LessFunctor lessFunctor;

  // 모두 bool 형식을 반환
  // 1. 함수 객체로 10과 20을 비교
  cout << lessFunctor(10,20) << endl;

  // 2. 함수로 10과 20을 비교
  cout << LessFun(10,20) << endl;
  
  // 3. 함수 포인터로 10과 20을 비교
  cout << LessPtr(10,20) << endl;

  // 결과 1 1 1
}
```

- 이 조건자 중 STL에서 제공하는 조건자는 모두 '함수 객체 조건자'
- <u>bool 형식을 반환하는 함수 객체</u>라고 해서 모두 함수 객체 조건자는 아니다
  - 조건자는 <u>객체의 상태값을 변경할 수 없다</u>는 '요구조건'을 만족해야 한다.
    - 함수 객체 조건자의 operator() 연산자 오버로딩 함수는 모두 const 함수
- STL 조건자는 내부 상태가 변경되지 않는 bool 형식을 반환하는 함수 객체

- 어댑터의 인자로 사용되는 함수 객체의 요구사항
  - 단항 함수 객체는 반드시 argument_type, result_type이 정의돼 있어야 한다.
    - 각각 함수의 인자 형식, 리턴 형식이다.
  - 이항 함수 객체는 반드시 first_argument_type, second_argument_type, result_type이 정의돼 있어야 한다.
    - 각각 함수의 첫 번째 인자 형식, 두 번째 인자 형식, 리턴 형식이다.
  
- 어댑터는 `함수 객체` -> `다른 함수 객체` 변환할 때 위의 정의 형식을 이용해 변환을 수행
  - 형식 정의를 쉽게 하려고 STL은 기본 클래스 unary_function과 binary_function을 제공
  - 함수 객체는 위 기본 클래스를 상속받아 만들면 된다.

**transform() 알고리즘의 plus<int> 연산**
```c++
template<typename T>
struct Plus{
  T operator() (const T& left, const T& right) const{
    return left + right;
  }
};

int main(){
  // STL 조건자 plus<int> 사용
  transform(v1.begin(), v1.end(), v3.begin()
  , binder1st<plus<int>>(plus<int>(), 100));

  // 사용자 정의 조건자 Plus<int> 사용, 에러 발생!!!
  // transform(v1.begin(), v1.end(), v3.begin()
  // , binder1st<Plus<int>>(Plus<int>(), 100));

  // v1 : 10 20 30
  // v3 : 110 120 130
}
```

- 단항 함수자 버전 사용
- 사용자 Plus<int>는 에러 발생
  - 어댑터 binder1st<int>가 이항 함수자를 단항 함수자로 변환하기 위해 first_argument_type, second_argument_type, result_type 형식 정의를 필요로 함

**first_argumet_type, second_argument_type, result_type 형식 정의**
```c++
template<typename T>
struct Plus{
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;

  T operator()(const T& left, const T& right) const{
    return left + right;
  }
};

int main(){
  ...
}
```

- 함수자에 first_argument_type, second_argument_type, result_type 형식을 정의할 수 있지만,
- 기본 클래스 unary_function과 binary_function을 상속받아 구현하는 것이 일반적이고 쉽다.

**기본 클래스 binary_function 함수**
이항 함수자 객체가 어댑터 변환이 가능하게 상속
```c++
template<typename T>
struct Plus:public binary_function<T,T,T>{
  T operator() (const T& left, const T& right) const{
    return left + right;
  }
};

int main(){
  ...
}
```
- 사용자 함수 객체(함수자)를 구현할 때 단항 함수는 기본 클래스 unary_function을 상속받아 만들고 이항 함수자는 binary_function을 상속받아 만들면 된다.
- 그래야 함수자를 언제든지 어댑터와 결합해서 사용할 수 있다.


## Section02 : 산술 연산 함수 객체

STL이 제공하는 산술 연산 함수 객체(함수자)
1. plus<T> : 이항 연산 함수자, + 연산
2. minus<T> : 이항 연산 함수자, - 연산
3. multiplies<T> : 이항 연산 함수자, * 연산
4. divides<T> : 이항 연산 함수자, / 연산
5. modulus<T> : 이항 연산 함수자, % 연산
6. negate<T> : 단항 연산 함수자, - 연산

**plus<T>의 사용**
```c++
plus<int> oPlus;
// 1. oPlus 객체로 10, 20 더하기. 암묵적 호출
cout << oPlus(10,20) << endl;
// 2. oPlus 객체로 10, 20 더하기. 명시적 호출
cout << oPlus.operator(10,20) << endl;

// 3. 임시 객체로 10, 20 더하기. 암묵적 호출(일반적인 사용)
cout << plus<int>()(10,20) << endl;
// 4. 임시 객체로 10, 20 더하기. 명시적 호출
cout << plus<int>().operator()(10,20) << endl;
```

- 함수자는 대부분 실행 문장에서만 사용되므로 3번째 호출 방법이 일반적
- 함수자이므로 함수처럼 호출 가능, 멤버 함수 operator() 연산자 호출

**사용자 Plus<T>**
```c++
template<typename T>
struct Plus:public binary_function<T,T,T>{  // 어댑터 적용이 가능하게
  T operator()(const T& left, const T& right) const{
    return left + right;
  }
};

int main(){
  Plus<int> oPlus;
  cout << oPlus(10,20) << endl;
  cout << oPlus.operator()(10,20) << endl;

  cout << Plus<int>()(10,20) << endl;
  cout << Plus<int>().operator()(10,20) << endl;
}
```

- 출력 결과, 구현 방법 모두 STL plus<T>와 같다.
- plus<T> 외에도 모든 산술 연산 함수자는 Plus<T>처럼 구현된다.

**산술 연산 함수자와 알고리즘**
```c++
// v3(v1+v2)
transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), plus<int>());

// v3(v1*v2)
transform(v1.begin(). v1.end(), v2.begin(), v3.begin(), multiplies<int>());

// v3(-v1)
transform(v1.begin(), v1.end(), v3.begin(), negate<int>());

// v3(v1 인접 원소의 차)
adjacent_difference(v1.begin(), v1.end(), v3.begin(), minus<int>());

// v3(v1 원소의 곱 누적)
partial_sum(v1.begin(), v1.end(), v3.begin(), multiplies<int>());

// v1 모든 원소의 곱
cout << accumulate(v1.begin(), v1.end(), 1, multiplies<int>());
```

- transform(b,e,t,f) 알고리즘에 사용된 f(negate<T>)만 단항 연산자이며 나머지는 모두 이항 연산자를 필요로 하는 알고리즘

## section03 : 비교 연산 조건자

STL이 제공하는 비교 연산 함수 객체 조건자
1. equal_to<T> : 이항 조건자, == 연산
2. not_equal_to<T> : 이항 조건자, != 연산
3. less<T> : 이항 조건자, < 연산
4. less_equal<T> : 이항 조건자, <= 연산
5. greater<T> : 이항 조건자, > 연산
6. greater_equal<T> : 이항 조건자 >= 연산

`조건자`(predicate)는
- <u>조건을 판단</u>해야 하는 대부분의 알고리즘에 사용.
- 특정 정렬 기준으로 정렬되어야 하는 컨테이너인 <u>연관 컨테이너</u>(set, map, multiset, multimap)에도 사용
- 비교(조건자)가 사용되어야 하는 STL 구성 요소의 <u>기본 조건자는 less\<T></u>

**조건자 less<T>**
```c++
less<T> oLess;

// 1. oLess 객체로 10,20을 비교 true. 암묵적 호출
cout << oLess(10,20) << endl;
// 2. oLess 객체로 10,20을 비교 true. 명시적 호출
cout << oLess.operator()(10,20) << endl;

// 3. 임시 객체로 10,20을 비교 true. 암묵적 호출(일반적인 사용)
cout << less<int>()(10,20) << endl;
// 4. 임시 객체로 10,20을 비교 true. 명시적 호출
cout << less<int>().operator()(10,20) << endl;
```

- 조건자도 대부분 한 문장 내에서 사용되므로 3번째 호출 방법이 일반적으로 사용되는 방법

**사용자 Less<T>**
```c++
template<typename T>
struct Less:public binary_function<T,T,bool>{ // 어댑터 적용이 가능하게
  bool operator()(const T& left, const T& right) const{
    return left < right;
  }
};

int main(){
  Less<int> oLess;
  cout << oLess(10,20) << endl;
  cout << oLess.operator()(10,20) << endl;
  
  cout << Less<int>()(10,20) << endl;
  cout << Less<int>().operator()(10,20) << endl;
}
```
- 이항 조건자이므로 어댑터 적용이 가능하게 binary_function 기본 클래스를 상속받아 구현
- 조건자는 상태가 변경될 수 없으므로 bool 형식을 반환하는 operator() 연산자 함수를 꼭 const 함수로 구현해야 한다.
