---
title:  "[뇌를 자극하는 C++ STL] Chapter10_STL 반복자"

categories:
  - STL
tags:
  - [Programming, Cpp, STL]

toc: true
toc_sticky: true
 
date: 2023-10-06
last_modified_at: 2023-09-19
---
<br>

반복자는 컨테이너의 원소를 순회하고 접근하는 일반화된 방법을 제공<br>
컨테이너와 알고리즘은 반복자를 통해 서로 통신(인터페이스)

## Section01 : 반복자의 종류

**반복자** : 포인터를 추상화한 클래스 객체, 포인터가 하지 못하는 더 많은 동작을 수행

1. 입력 반복자(input iterator) : 전방향 읽기(istream)
    - *iter(읽기), ->(멤버 읽기), ++(전방향 이동), ==(비교), !=(비교), iterator(iter) 연산 제공
2. 출력 반복자(output iterator) : 전방향 쓰기(ostream)
    - *iter=x(쓰기), ++, iterator(iter)(복사 생성자) 연산 제공
3. 순방향 반복자(forward iterator) : 전방향 읽기, 쓰기
    - *iter, ->, ++, ==, !=, =(대입), iterator()(기본 생성자), iterator(iter) 연산 제공
4. 양방향 반복자(bidirectional iterator) : 양방향 읽기, 쓰기(list, set, multiset, map, multimap)
    - 순방향 반복자 기능 `+` --(역방향 이동) 연산 제공
5. 임의 접근 반복자(random access iterator) : 랜덤 읽기, 쓰기(vector, deque)
    - 양방향 반복자 기능 `+` 반복자의 랜덤 연산([], +=, -=, +, -, <, >, <=, >=) 연산 제공

반복자에서 `순차열`(sequence)과 `구간`(range)은 중요한 개념.
- 순차열 : 순서 있는 원소의 집합
    - 하나의 시작과 끝을 나타내는 반복자의 쌍으로 표현, 이게 구간(range)

## Section02 : X::iterator와 X::const_iterator

STL의 <u>모든 컨테이너</u>는 <u>정방향 반복자</u>의 형식 X::iterator와 X::const_iterator, <u>역방향 반복자</u> 형식 X::reverse_iterator와 X::const_reverse_iterator를 정의 

정방향 반복자의 내장 형식
1. X::iterator :  반복자가 가리키는 원소 <u>읽기, 쓰기 가능</u>
2. X::const_iterator : 정방향 반복자의 내장 형식. 반복자가 가리키는 원소의 <u>읽기 가능</u> 

- <u>list, set, multiset, map, multimap</u> 컨테이너의 X::iterator, X::const_iterator는 `양방향 반복자`
- <u>vector, deque</u> 컨테이너의 X::iteartor, X::const_iterator는 `임의 접근 반복자`

- begin() 멤버 함수 : 컨테이너 순차열의 첫 원소를 가리키는 반복자
- end() 멤버 함수 : 순차열의 끝 표시(past-the-end) 반복자
- 모두 X::iterator 형식이며 포인터처럼 X::iterator 형식은 X::const_iterator 형식으로 자동 변환

**iterator와 const_iterator**

```c++
// iterator 읽기 가능
for(vector<int>::iterator iter = v.begin(); iter!=v.end(); ++iter)
    cout << *iter << " ";

// const iterator 읽기 가능
for(vector<int>::const_iterator citer = v.begin(); citer!=v.end(); ++citer)
    cout << *citer << " ";

vector<int>::iterator iter = v.begin();
vector<int>::const_iterator citer = v.begin();

*iter = 100;    // 쓰기 가능
// *citer = 100;    // 쓰기 불가능
```

- iter : iterator 반복자, 원소의 읽기, 쓰기 가능
- citer : const_iterator 반복자, 원소의 읽기만 가능

**X::iterator, X::const_iterator, const X::iterator, const X::const_iterator 반복자 비교**

반복자가 가리키는 원소의 위치를 변경하지 않으려면 const 키워드 사용하여 반복자를 const화
```c++
vector<int>::iterator iter = v.begin();
vector<int>::const_iterator citer = v.begin()+1;
const vector<int>::iterator const_iter = v.begin()+2;
const vector<int>::const_iterator const_citer = v.begin()+3;

// iter는 모두 가능
*iter = 100;    // 가리키는 원소 변경 가능
++iter; // 반복자 변경 가능

// citer
*citer = 200;   // 가리키는 원소 변경 XXX
++citer;    // 반복자 변경 가능

// const_iter
*const_iter = 300;  // 가리키는 원소 변경 가능
++const_iter;   // 반복자 변경 XXX

// const_citer
*const_citer = 400; // 가리키는 원소 변경 XXX
++const_citer;  // 반복자 변경 XXX
```

- const X::iterator : 반복자 자체가 const 객체
- X::const_iterator : 반복자가 가리키는 원소가 const 객체

**vector의 임의 접근 반복자와 list의 양방향 반복자**

vector, deque 컨테이너는 배열 기반 컨테이너로 임의 접근 반복자 지원<br>
list, set, multiset, map, multimap은 양방향 반복자 지원
```c++
vector<int>::iterator:iterator viter = v.begin();
list<int>::iterator liter = lt.begin();

cout << *viter;
cout << *liter;

cout << *++viter;
cout << *++liter;

cout << *--viter;
cou t<< *--liter;

viter += 2; // 임의 접근 반복자는 [], +=, -=, +, -, <, >, <=, >= 연산가능
// liter += 2;  // 양방향 반복자 불가능 XXX


vector<Point>::iterator ptVIter = ptVector.begin();
ptVIter->Print();

list<Point>::iterator ptLIter = ptList.begin();
ptLIter->Print();
```

- -> 연산자로 가리키는 원소의 멤버를 접근
- 임의 접근 반복자는 양방향 반복자 기능 `+` [],+=,-=,+,-,<,>,<=,>= 연산 기능을 더 제공
- `정렬관련 알고리즘`은 이 연산이 가능해야 하므로 `임의 접근 반복자`를 요구함
- vector, deque 컨테이너에 동작

## Section03 : X::reverse_iterator와 X::const_reverse_iterator

역방향 반복자 형식의 내장 형식
1. X::reverse_iterator : 반복자가 가리키는 원소 <u>읽기, 쓰기 가능</u>
2. X::const_reverse_iterator : 반복자가 가리키는 원소의 <u>읽기 가능</u>

- list,set,multiset,map,multimap 컨테이너의 X::reverse_iterator와 X::const_reverse_iterator는 양방향 반복자
- vector,deque 컨테이너의 X::reverse_iterator와 X::const_reverse_iterator는 임의 접근 반복자

- rbegin() 멤버 함수 : 컨테이너 <u>순차열의 끝 표시(past-the-end) 반복자</u>
- rend() 멤버 함수 : 순차열의 첫 원소를 가리키는 반복자
- 모두 X::reverse_iterator 형식
- 포인터처럼 X::reverse_iterator 형식은 X::const_reverse_iterator 형식으로 자동 변환

**X::iterator와 X::reverse_iterator의 동작**

X::reverse_iterator 반복자는 역방향 반복자로 X::iterator 반복자와 반대로 동작

```c++
// v : 10 20 30 40 50
// iterator
for(vector<int>::iterator iter = v.begin(); iter!=v.end(); ++iter)
    cout << *iter;
// 출력 : 10 20 30 40 50

// reverse_iterator
for(vector<int>::reverse_iterator riter = v.rbegin(); riter!=v.rend(); ++riter)
    cout << *riter;
// 출력 : 50 40 30 20 10
```

- riter를 ++하면 반복자가 순차열의 역방향으로 이동
- 정방향 반복자는 가리키는 원소의 값을 참조, <u>역방향 반복자는 가리키는 다음 원소의 값을 참조</u>
    - 가리키는 원소와 실제 값이 다름
    - 정방향 반복자로 표현한 순차열과 역방향 반복자로 표현한 순차열이 서로 같도록 하기 위함
    - 다시 역방향 반복자를 정방향 반복자로 변환하더라도 순차열의 원소는 같게 됨

**반복자 어댑터 reverse_iterator<T>**

X::reverse_iterator와 X::const_reverse_iterator 형식은 반복자 어댑터 `reverse_iterator<T>`를 사용해 X::iterator와 X::const_iterator를 반대로 동작하도록 변환한 형식

```c++
// reverse_iterator 어댑터로 정방향 반복자를 역방향 반복자로 변환
reverse_iterator<vector<int>::iterator> rbiter(v.end());
reverse_iterator<vector<int>::iterator> reiter(v.begin());

// v[rbiter, reiter)
for(; rbiter!=reiter; ++rbiter)
    cout << *rbiter;
// 출력 : 50 40 30 20 10

// v[rbegin(), rend())
for(vector<int>::const_reverse_iterator riter=v.rbegin(); riter!=v.rend(); ++riter)
    cout << *riter;
// 출력 : 50 40 30 20 10
```

**네 반복자 형식의 변환**

```c++
vector<int>::iterator iter = v.begin()+1;
vector<int>::const_iterator citer = iter;   // 비 const -> const 형변환

// 정방향->역방향 암묵적 변환(생성자 이용)
// vector<int>::reverse_iterator riter(iter)과 같다
reverse_iterator<vector<int>::iterator> riter(iter);    
// vector<int>::const_reverse_iterator criter(riter)과 같다
reverse_iterator<vector<int>::const_iterator> criter(riter);

cout << *iter;  // 20
cout << *citer; // 20
cuot << *riter; // 10
cout << *criter;    // 10

// 역방향->정방향 base() 멤버 함수
cout << "riter.base() => iter : " << *riter.base(); // 20
cout << "criter.base() => citer : " << *criter.base();  // 20
```

- 포인터처럼 비 const 반복자는 const 반복자로 형변환되며
- 정방향 반복자는 역방향 반복자로 암묵적 변환(생성자를 이용) 됨
- 역방향 반복자는 base() 멤버 함수를 사용하여 정방향 반복자로 형변환

## Section04 : 삽입 반복자

삽입 반복자 : 순차열에 원소를 `삽입(insert)`할 수 있게 반복자를 변환하는 `반복자 어댑터`
- 모든 알고리즘은 <u>기본적으로 덮어쓰기 모드</u>로 동작
- *삽입 반복자를 사용하면 알고리즘이 <u>삽입 모드</u>로 동작하게 할 수 있다.*

1. inserter() : insert_iterator 객체 생성, 컨테이너의 <u>insert()</u> 멤버 함수를 호출해 삽입 모드로 동작하게 한다.
2. back_inserter() : back_insert_iterator 객체를 생성, 컨테이너의 <u>push_back()</u> 멤버 함수를 호출해 뒤쪽에 추가(삽입)하도록 한다.
3. front_inserter() : front_insert_iterator 객체를 생성, 컨테이너의 <u>push_fron()</u> 멤버 함수를 호출해 앞쪽에 삽입하도록 한다.

- <u>모든 컨테이너</u>는 `insert()` 멤버 함수를 제공하므로 inserter()를 사용할 수 있지만
- <u>시퀀스 컨테이너</u>(vector, deque, list)만이 `back_inserter()`를 사용할 수 있고
- <u>deque, list</u>만이 `front_insert_iterator()`를 사용할 수 있다.

**삽입 반복자 어댑터 inserter()**

*덮어쓰기 모드는 원소의 개수가 변하지 않지만, 삽입 모드는 원수의 개수가 늘어남*

```c++
// v1 : 10 20 30 40 50

vector<int> v2; // size : 0인 vector
// copy(v1.begin(), v1.end(), v2.begin());  // 에러 XXX

// 객체 생성 후 호출
insert_iterator<vector<int>> insert(v2, v2.begin());
copy(v1.begin(), v1.end(), insert); 

copy(v1.begin(), v1.end(), inserter<vector<int>>(v2, v2.begin()));

// v1 : 10 20 30 40 50 
// v2 : 10 20 30 40 50 
```

- `inserter<vector<int>>(v2, v2.begin())` : <u>v2.begin() 반복자</u>를 v2의 insert() 멤버 함수를 호출하는 <u>삽입 반복자로 변환</u>

**back_inserter(), front_inserter()**

list는 back_inserter, front_inserter 반복자 어댑터를 사용할 수 있다.

```c++
// v : 10 20 30 40 50 
// lt1 : 1 2 3
// lt2 : 1 2 3 

copy(v.begin(), v.end(), back_inserter<list<int>>(lt1));
copy(v.begin(), v.end(), front_inserter<list<int>>(lt2));

// v : 10 20 30 40 50 
// lt1 : 1 2 3 10 20 30 40 50 
// lt2 : 50 40 30 20 10 1 2 3
```

- `back_inserter<list<int>>(lt1)` : lt1의 push_back() 멤버 함수를 호출하는 반복자 생성
- `front_inserter<list<int>>(lt2)` : lt2의 push_front() 멤버 함수를 호출하는 반복자 생성