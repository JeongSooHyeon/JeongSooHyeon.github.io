---
title: "위클리 페이퍼 - 3주차 (HashSet의 내부 동작 방식, O(n)과 O(logN)의 성능 차이)"
categories:
  - WeeklyPaper
tags:
  - [Programming]
toc: true
toc_sticky: false
date: 2026-01-19
last_modified_at: 2026-01-19
---

<br>
---


# HashSet의 내부 동작 방식과 중복 제거 메커니즘

## HashSet은 HashMap으로 동작한다

HashSet은 내부적으로 HashMap을 사용하여 구현되어 있습니다.

- HashMap은 Key-Value 쌍으로 데이터를 저장합니다.
- Key는 중복을 허용하지 않고, Value는 중복을 허용합니다.
- HashSet에 값을 저장하면 HashMap의 Key에 저장됩니다.
- Map의 Key는 중복된 값이 들어가지 못한다는 점과 Set에는 중복된 값이 들어가지 못하는 공통된 특징을 이용한 구조입니다.

```java
// HashSet 내부 구현 (간략화)
public class HashSet<E> {
    private HashMap<E, Object> map;
    private static final Object PRESENT = new Object();
    
    public boolean add(E e) {
        return map.put(e, PRESENT) == null;
    }
}
```

---

## 해시 테이블 구조

HashSet은 내부적으로 다음과 같은 구조를 가집니다.

```
버킷 배열 + 각 버킷의 연결 리스트(또는 레드-블랙 트리)
```

### 버킷(Bucket)이란?

해시 테이블에서 실제로 값이 저장되는 장소입니다. 각 키는 해싱 프로세스를 거쳐 테이블의 어느 인덱스(버킷)에 저장될지 결정됩니다.

### 해시 충돌(Hash Collision)

버킷의 개수는 유한하기 때문에 다른 두 객체의 해시 함수 출력값이 동일할 수 있습니다. 이 경우 해시 테이블의 같은 인덱스(버킷)에 저장됩니다.

**중요한 원칙**
- 같은 객체는 반드시 같은 해시 값을 가집니다.
- 같은 해시 값을 가진다고 같은 객체라고 볼 수는 없습니다.

---

## 중복 제거 메커니즘

HashMap은 `hashCode()`와 `equals()` 두 메서드를 활용하여 중복을 구별합니다.

### hashCode()

객체를 정수 형태로 변환(해싱)합니다. 객체의 주소값을 변환하여 객체마다 고유한 값을 생성합니다.

```java
@Override
public int hashCode() {
    return Objects.hash(id, name);
}
```

### equals()

주소값을 비교하거나 두 객체의 내용이 같은지 확인합니다.

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    User user = (User) obj;
    return Objects.equals(id, user.id) && Objects.equals(name, user.name);
}
```

---

## 왜 hashCode()와 equals()를 함께 사용할까?

`equals()`로 객체가 같은지 비교할 수 있고, `hashCode()`로 각 객체마다 고유한 값을 줄 수 있다면 왜 두 메서드를 함께 사용할까요?

**HashSet과 HashMap이 해시 테이블 구조를 기반으로 구현되었기 때문입니다.**

- `hashCode()`로 다른 객체인지 빠르게 판단할 수 있습니다.
- 해시 충돌이 발생한 경우 `equals()`로 정말 같은 객체인지 확인합니다.

---

## 객체 비교 과정

해시 구조에서 두 객체를 비교할 때는 다음 단계를 거칩니다.

### 1단계: hashCode()로 버킷 찾기

테이블의 모든 객체와 일일이 비교하지 않고 `hashCode()`로 버킷을 찾아 데이터를 탐색합니다.

```java
int bucket = hashCode() % bucketSize;
```

### 2단계: equals()로 동등성 확인

같은 버킷에 여러 객체가 있는 경우 `equals()`로 실제로 동등한 객체가 있는지 확인합니다.

```
┌─────────────────────────────────┐
│  HashSet에 객체 추가 시도       │
└────────────┬────────────────────┘
             │
             ▼
     ┌───────────────┐
     │ hashCode() 호출│
     └───────┬───────┘
             │
             ▼
     ┌───────────────┐
     │  버킷 위치 찾기 │
     └───────┬───────┘
             │
             ▼
     ┌─────────────────────┐
     │ 해당 버킷에 데이터 있음? │
     └────┬───────────┬────┘
         없음        있음
          │           │
          ▼           ▼
      ┌──────┐  ┌──────────┐
      │ 추가 │  │equals() 호출│
      └──────┘  └─────┬────┘
                      │
                ┌─────┴─────┐
               같음        다름
                │            │
                ▼            ▼
            ┌──────┐    ┌──────┐
            │ 거부 │    │ 추가 │
            └──────┘    └──────┘
```

---

## HashSet이 효율적인 이유

### 빠른 탐색 속도

해시 값을 사용하여 데이터가 저장된 버킷을 빠르게 찾기 때문에 평균 시간 복잡도가 **O(1)**입니다.

### 효율적인 중복 체크

1. 모든 요소를 순회하지 않고 `hashCode()`로 해당 버킷만 확인합니다.
2. 버킷 내에서만 `equals()`로 비교하므로 비교 횟수가 최소화됩니다.

```java
// 일반 List로 중복 체크 - O(n)
boolean isDuplicate = list.contains(newElement);

// HashSet으로 중복 체크 - O(1)
boolean isDuplicate = hashSet.contains(newElement);
```

---

## 정리

HashSet은 내부적으로 HashMap으로 동작하며, 해시 구조에서 `hashCode()`와 `equals()`를 활용하여 객체를 빠르게 찾고 비교합니다. 이를 통해 중복을 효율적으로 체크할 수 있습니다.

**핵심 원리**
1. `hashCode()`로 버킷 위치를 빠르게 찾습니다.
2. 같은 버킷 내에서만 `equals()`로 실제 동등성을 확인합니다.
3. 평균 O(1)의 시간 복잡도로 중복 체크가 가능합니다.

---

## 참고 자료

- https://syleeblog.tistory.com/18
- https://jay-ya.tistory.com/118
- https://velog.io/@uurr/HashSet-파고들기



# O(n)과 O(log n)의 성능 차이

## 실생활 예시: 숫자 맞추기 게임

### O(log n): 이분 탐색 방식

1부터 100까지의 숫자 맞추기 게임에서 매번 "너무 높아요" 또는 "너무 낮아요"라는 힌트를 받습니다.

**전략**
1. 첫 번째 추측: 50 (범위의 절반)
2. 너무 높다면 1~49 중에서, 너무 낮다면 51~100 중에서 다시 절반을 선택
3. 매번 남은 범위의 절반씩 제거

**필요한 추측 횟수**: ceil(log₂(n))

```
1부터 100까지: 최대 7번 추측
1부터 1,000까지: 최대 10번 추측
1부터 1,000,000까지: 최대 20번 추측
```

### O(n): 선형 탐색 방식

같은 게임에서 "정답입니다" 또는 "다시 시도하세요"라는 말만 듣습니다.

**전략**
1. 1부터 시작해서 순차적으로 추측
2. 2, 3, 4, 5... 정답을 찾을 때까지 계속

**필요한 추측 횟수**
- 평균: n/2번
- 최악: n번

```
1부터 100까지: 평균 50번, 최악 100번 추측
1부터 1,000까지: 평균 500번, 최악 1,000번 추측
1부터 1,000,000까지: 평균 500,000번, 최악 1,000,000번 추측
```

---

## 데이터 크기별 성능 비교

### 데이터 1백만 개일 때

| 알고리즘 | 연산 횟수 | 계산식 |
|---------|----------|--------|
| O(log n) | 약 20번 | log₂(1,000,000) ≈ 20 |
| O(n) | 평균 500,000번<br>최악 1,000,000번 | n/2 또는 n |


## 핵심 차이점

### O(log n)의 특징

- 데이터가 2배 증가해도 연산은 단 1번만 증가
- 매우 큰 데이터셋에서도 빠른 성능 유지
- 이분 탐색, 균형 이진 트리 등에서 사용

```java
// 이분 탐색 예시
int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

### O(n)의 특징

- 데이터가 2배 증가하면 연산도 2배 증가
- 작은 데이터셋에서는 괜찮지만 큰 데이터셋에서는 비효율적
- 선형 탐색, 단순 순회 등에서 사용

```java
// 선형 탐색 예시
int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) return i;
    }
    return -1;
}
```

---

## 시각적 비교

```
데이터 크기에 따른 연산 횟수 증가

O(n):
n=10      ████████████████████ (10)
n=100     ████████████████████████████████████████ (100)
n=1000    ████████████████████████████████████████████████████████ (1000)

O(log n):
n=10      ███ (3.3)
n=100     ██████ (6.6)
n=1000    █████████ (10)
```

---

## 실제 사용 예시

### O(log n)을 사용하는 경우

- 정렬된 배열에서 검색 (이분 탐색)
- 균형 이진 탐색 트리 (AVL, Red-Black Tree)
- 이진 힙에서의 삽입/삭제

### O(n)을 사용하는 경우

- 정렬되지 않은 배열에서 검색
- 배열의 모든 요소 출력
- 리스트의 모든 요소 순회

---

## 결론

O(log n)과 O(n)의 차이는 데이터가 커질수록 극적으로 벌어집니다. 

- **1백만 개 데이터**: O(log n)은 20번, O(n)은 평균 50만 번
- **1조 개 데이터**: O(log n)은 40번, O(n)은 평균 5000억 번

이것이 정렬된 데이터에서 이분 탐색을 사용하는 것이 중요한 이유입니다.

## 참고 자료
https://www.reddit.com/r/AskComputerScience/comments/1ec9i3p/explanation_between_on_and_olog_n/?tl=ko