---
title:  "TIL - 2026/01/26/월"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-26
last_modified_at: 2026-01-26
---
<br>

# Spring Bean 심화 - TIL

## Bean의 이해

### Bean vs 자바빈 vs POJO

**Bean**
- Spring이 관리하는 객체입니다.

**자바빈**
- getter, setter를 가진 일반 자바 객체입니다.

**POJO (Plain Old Java Object)**
- 우리가 작성한 순수 자바 코드로, Bean이 되기 위한 클래스입니다.
- 특정 환경이나 기술에 종속되지 않습니다.
- 모든 Bean이 POJO는 아니지만, 대부분의 Bean은 POJO입니다.
- 모든 POJO가 Bean은 아닙니다.

### Bean 등록 시점

**Bean이 등록되는 시점: 애플리케이션이 실행되는 시점**

일반적인 경우 (스프링 Bean의 스코프를 변경하지 않았을 때) Singleton 스코프가 기본값입니다.

---

## Bean 등록 방법

### 1. Annotation 기반 (@Component)

```java
@Component
public class UserService {
    // Bean 이름은 클래스 이름의 첫 글자를 소문자로 변경: userService
}
```

**Component Scan**
- `@SpringBootApplication`은 내부적으로 컴포넌트 스캔을 가지고 있습니다.
- 하위 폴더에 있는 컴포넌트들을 모두 스캔합니다.

### 2. Java Config 기반 (@Configuration + @Bean)

```java
@Configuration // Bean을 등록할 정보가 담긴 클래스
public class AppConfig {
    
    @Bean // 메서드가 반환하는 객체를 Bean으로 등록, 메서드명이 Bean 이름이 됨
    public UserService userService() {
        return new UserService();
    }
}
```

**Bean 이름 충돌**
- Java 기반(@Configuration, @Bean)과 Annotation 기반(@Component)이 혼용될 때는 충돌이 발생하지 않습니다.

---

## Bean 스코프

### Singleton (기본값)

```java
@Component
// @Scope("singleton") - 기본값이므로 생략 가능
public class UserService {
}
```

**특징**
- 애플리케이션 전체에서 단일 인스턴스를 공유합니다.
- 생애주기: 실행(생성) ~ 소멸

### Prototype

```java
@Component
@Scope("prototype")
public class PrototypeBean {
}
```

**특징**
- 요청할 때마다 새로운 인스턴스를 생성합니다.
- 생애주기: 생성까지만 관리, 소멸은 관리하지 않음

### Request Scope

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class LoginUser {
}
```

**특징**
- HTTP 요청마다 새로운 인스턴스를 생성합니다.
- 요청이 끝나면 인스턴스가 폐기됩니다.

### Session Scope

```java
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserSession {
}
```

**특징**
- 상태를 유지하기 위해 사용합니다 (로그인 중인 상태).
- 인증된 정보를 담고 있습니다.
- 세션당 하나의 인스턴스를 생성합니다.
- 세션이 종료되면 인스턴스가 폐기됩니다.

**HTTP 프로토콜의 특징**
1. 비연결성
2. 무상태성

---

## IoC 컨테이너와 Bean 생명주기

### ApplicationContext

```java
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);
```

**특징**
- 추상화되어 있으며 구현체가 많습니다.
- 대부분 `AnnotationConfigApplicationContext`를 사용합니다 (Annotation 기반).

### BeanFactory

Bean 생성, 조회, 활용의 최소 기능만 제공합니다. 실무에서는 잘 사용하지 않습니다.

### Bean의 생명주기

```
1. 메타데이터 읽기
2. Bean 생성
3. 의존성 주입
4. 초기화
5. 사용
6. 소멸
```

**메타데이터**
- Bean이 되기 위한 정보를 담고 있습니다.
- Annotation이 Bean에 대한 정보를 주는 역할을 담당합니다.

---

## 의존성 주입 (DI) 상세

### 생성자 주입 (권장)

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
}
```

**장점**
- null이 아님을 보장합니다 (final 사용 가능).
- 초기화를 강제합니다.
- 불변성을 보장합니다.

### Setter 주입 (잘 사용 안 함)

```java
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**단점**
- 의존성 주입 시기가 늦습니다 (인스턴스화 후).
- null일 수 있습니다.

### Field 주입 (사용 금지)

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; // 사용하지 마세요!
}
```

**단점**
- 테스트가 불가능합니다.
- DI 프레임워크에 강하게 결합됩니다.
- Spring에 의존하게 되어 POJO 지향에 어긋납니다.
- 주입되는 순간 Spring에 강하게 결합됩니다.

### 의존성 주입 시 Spring이 판단하는 기준

1. 해당 타입의 Bean을 찾습니다.
2. 두 개 이상이면 생성자의 Bean 변수 이름과 같은 것을 찾습니다.

---

## 순환 참조 해결 방법

```java
// A가 B를 의존하고, B가 A를 의존하는 경우
```

**해결 방법**
1. 이벤트 기반으로 변경
2. 둘을 상속받는 새로운 클래스 만들기

---

## 프록시 (Proxy)

### 개념

누군가가 원본 객체를 감싸서 만드는 것입니다.

**웹 스코프가 프록시가 필요한 순간**
- Controller나 Service까지만 접근할 수 있을 때
- CGLIB가 기본값으로 사용됩니다 (상속 방식).

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean {
}
```

---

## Life-cycle 콜백

Bean이 생성될 때와 소멸될 때 자동으로 호출되는 콜백입니다.

```java
@Component
public class DatabaseConnection {
    
    @PostConstruct
    public void init() {
        // Bean 생성 후 초기화 작업
    }
    
    @PreDestroy
    public void destroy() {
        // Bean 소멸 전 정리 작업
    }
}
```

---

## 설정 파일 (application.yml)

### 설정 변경 방법

1. 코드 레벨에서 설정 (환경 설정 클래스 만들기)
2. yml 파일에 직접 등록

**둘 중 하나만 선택해야 합니다.**

### yml 파일 사용이 적절한 경우

- 개발 환경에서는 Security를 사용하지 않고, 운영 환경에서만 사용할 때
- 환경별로 다른 설정이 필요할 때

### DB 접근 정보 (보안 주의)

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb  # 1. URL (이것도 위험!)
    username: user                          # 2. ID
    password: pass                          # 3. Password
```

**주의**: URL도 위험합니다. 많은 정보가 노출될 수 있으므로 민감한 정보는 환경 변수나 별도 보안 저장소를 사용해야 합니다.

---

## 테스트와 Spring

### 테스트 프레임워크

JUnit만 있어도 테스트할 수 있습니다. Spring 없이도 테스트 가능합니다.

**POJO를 유지해야 하는 이유**
- Spring 종속성이 거의 없는 코드도 존재할 수 있습니다.
- 코드 레벨에서 봤을 때 최대한 Spring에 의존하지 말아야 합니다.

---

## 핵심 정리

- **Bean 등록 시점**: 애플리케이션 실행 시점 (Singleton 기본)
- **@Bean**: 메서드가 반환하는 객체를 Bean으로 등록
- **Singleton**: 생애주기는 실행~소멸
- **Prototype**: 생성까지만 관리, 소멸은 관리 안 함
- **생성자 주입 권장**: null 방지, 불변성 보장, 초기화 강제
- **Field 주입 금지**: 테스트 불가, Spring에 강하게 결합
- **POJO 지향**: 최대한 Spring에 의존하지 않는 코드 작성
- **설정 방법**: 코드 레벨 또는 yml 파일 중 하나만 선택