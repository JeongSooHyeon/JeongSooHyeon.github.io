---
title:  "TIL - 2026/01/22/목"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-22
last_modified_at: 2026-01-22
---
<br>

# Spring 핵심 개념 - TIL

## 계층형 아키텍처

비즈니스 로직을 계층별로 분리하여 관리하는 구조입니다.

---

## 프레임워크란?

프레임워크는 뼈대, 틀, 구조를 제공합니다.

**특징**
- 프레임을 기반으로 내부 구성 요소만 교체합니다.
- 전반적인 구조를 제공합니다.
- 공통된 작업(서버 통로 열기 등)을 프레임워크가 처리합니다.

**장점**
1. 개발 시간을 줄일 수 있습니다.
2. 일정 수준 이상의 품질을 기대할 수 있습니다.
3. 유지 보수가 쉽습니다 (비즈니스 로직만 남아있기 때문).

---

## IoC (제어의 역전)

### 개념

개발자가 갖고 있던 제어권을 Spring에게 넘기는 것입니다.

- 기존: 개발자가 main에서 직접 객체 생성 및 관리
- IoC: 객체 생성과 관리를 외부(Spring)에게 위임

생성자가 호출되는 시점에 제어권이 있으며, 이 제어권을 Spring이 가져갑니다.

### IoC 컨테이너 (Spring 컨테이너)

의존 관계 주입을 Spring 컨테이너가 담당합니다.

**BeanFactory**
- Bean 객체들을 생성, 관리, 설정, 소멸까지 전체 생명주기를 책임집니다.
- Bean을 생성하고 반환합니다.

**ApplicationContext**
- BeanFactory를 확장한 인터페이스입니다.
- 실무에서 가장 많이 사용합니다.
- 객체는 컨테이너가 소멸되는 시점에 대부분 소멸됩니다.

> **중요**: 빈은 애플리케이션이 실행되는 시점에 미리 만들어지고 종료할 때 사라집니다.

---

## Configuration Metadata

Bean으로 등록할 객체와 생성 방법에 대한 최소한의 정보입니다.

**설정 방법**
1. Java Config
2. **Annotation** (가장 많이 사용)

---

## Bean

### 정의

Spring 컨테이너가 관리하는 객체입니다. 일반적으로 POJO(Plain Old Java Object)입니다.

**POJO 특징**
- 특정 환경이나 기술에 종속되지 않습니다.
- 대부분의 Bean은 POJO이지만 아닐 수도 있습니다.
- 모든 POJO가 Bean은 아닙니다.

### Bean 등록 방법

**@Component**
- 클래스 레벨에 사용합니다.
- 이 클래스를 인스턴스화하면서 Bean이 됩니다.

```java
@Component
public class UserService {
    // ...
}
```

**@Configuration + @Bean**
- @Configuration은 클래스 레벨에 사용합니다.
- @Bean은 메서드 레벨에 사용합니다.
- 반환되는 객체를 Bean으로 등록합니다.

```java
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }
}
```

### Bean 스코프

변수의 생애주기를 관리하는 스코프를 가지고 있습니다.

| 스코프 | 설명 | 비고 |
|--------|------|------|
| **singleton** | 단일 인스턴스를 공유해서 사용 | **(기본값)** |
| **prototype** | 요청할 때마다 새 인스턴스 생성 | |
| request | 하나의 HTTP 요청마다 인스턴스 생성 | |
| session | 세션마다 인스턴스 생성 | |

---

## DI (의존성 주입)

### 개념

다른 객체를 사용할 때 발생하는 관계입니다.

- `new`를 사용하면 결합도가 높아집니다 (해당 객체가 Bean일 경우).
- `@Bean`을 통해 주입받지 않으면 결합도가 높습니다.

**의존성이 필요한 이유**: 객체들 간의 유기적인 관계를 통해 하나의 애플리케이션을 만들기 위해서입니다.

### 의존성 주입 방법

**1. 생성자 주입 (권장)**

```java
@Component
public class UserService {
    private final UserRepository userRepository;
    
    // 생성자가 1개면 @Autowired 생략 가능
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**장점**
- 의존성 주입 시기가 빠릅니다 (인스턴스화와 동시).
- 초기화가 강제됩니다 (final 키워드 사용 가능).
- null일 가능성이 없습니다.

**2. Setter 주입 (잘 사용 안 함)**

동적으로 객체를 바꿔끼워야 할 때 사용합니다.

**단점**
- 의존성 주입 시기가 늦습니다 (인스턴스화 후).
- null일 수 있습니다.

**3. Field 주입 (사용하지 않음)**

```java
@Autowired
private UserRepository userRepository; // 권장하지 않음
```

---

## AOP (관점 지향 프로그래밍)

### 개념

비즈니스 로직과 별개로 공통된 기능을 묶어서 관리할 수 있는 것입니다. 객체지향 프로그래밍의 한계를 극복하기 위해 등장했습니다.

### 관심사의 분리

**공통 관심 사항 (Cross-Cutting Concerns)**
- 로깅
- 보안
- 트랜잭션
- 어디든 적용되어야 하는 기능들

**핵심 관심 사항 (Core Concerns)**
- 커피 주문
- 메뉴 등록
- 주문 변경
- 비즈니스 로직

```
┌─────────────────────────────────────┐
│         공통 관심 사항 (AOP)         │
│    (로깅, 보안, 트랜잭션 등)         │
├─────────────────────────────────────┤
│  핵심 관심 사항 (비즈니스 로직)      │
│                                     │
│  - 커피 주문                        │
│  - 메뉴 등록                        │
│  - 주문 변경                        │
└─────────────────────────────────────┘
```

AOP를 사용하면 공통 관심 사항을 분리하여 코드 중복을 줄이고 유지보수성을 높일 수 있습니다.

---

---

## AOP 구현

### AOP를 만들기 위한 애노테이션

```java
@Aspect
@Component
public class LoggingAspect {
    // AOP를 만들기 위해서는 Spring 컨테이너의 도움이 필요
}
```

### Pointcut 표현식

```java
@Around("execution(* com.codeit..*(..))")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    // ...
}
```

**표현식 의미**
- `*`: 모든 반환 타입
- `com.codeit..*`: codeit 하위에 있는 모든 클래스 (위치 지정)
- `*(..)`: 이름 아무거나, 파라미터 모두

**JoinPoint**
- 현재 메서드의 정보를 담고 있습니다.
- 리턴 타입: Object (와일드카드 `*`를 사용했기 때문)

### AOP 주요 개념

| 용어 | 설명 |
|------|------|
| **Aspect** | 공통 관심사가 있는 모듈 자체 (공통 관심사를 별도 모듈로 분리한 것) |
| **Advice** | 실행될 공통 기능 (Around: 메서드 실행 전후 관리) |
| **Joint Point** | Advice가 적용 가능한 지점 (메서드 실행 전/후) |
| **Pointcut** | Aspect를 누구에게 적용할지 결정 |
| **Weaving** | Advice를 비즈니스 로직에 적용하는 과정 |

### 프록시 객체

AOP는 프록시 패턴을 사용합니다.

```
프록시 객체 = 타겟 객체 + 추가한 기능 객체
```

메서드가 호출되는 런타임 시점에만 부가 기능을 적용할 수 있습니다.

### ⚠️ 중요: Self-Invocation 문제

**클래스 내부의 메서드 호출에는 AOP가 적용되지 않습니다.**

```java
@Service
public class UserService {
    @Transactional
    public void methodA() {
        methodB(); // AOP 적용 안 됨!
    }
    
    @Transactional
    public void methodB() {
        // ...
    }
}
```

### 트랜잭션과 AOP

트랜잭션이 AOP를 활용하고 있다는 점을 알아두세요.

---

## Spring 생태계

### Spring Data
- 데이터베이스를 사용할 때 연결을 도와줍니다.

### Spring Security
- 보안과 관련된 모든 기능을 제공합니다.
- **인증(Authentication)**: 신원 증명
- **인가(Authorization)**: 신원이 증명되면 적절한 권한 부여

### Spring Cloud
- MSA, 분산 시스템에서 필요한 기능을 제공합니다.
- 여러 개의 설정 파일을 하나로 관리합니다.

### Spring Batch
- 배치 처리 시스템: 주기적으로 처리해야 하는 작업을 관리합니다.

---

## Spring Boot

### Spring Boot란?

Spring을 래핑한 프레임워크입니다.

- **Spring Boot 2**: Spring 5 버전 사용
- **Spring Boot 3**: Spring 6 버전 사용 (Java 17 이상 필요)

**Bootstrap**: 아무것도 없는 곳에서 실행 가능한 상태까지 끌어올리는 것 (설정 불러오기)

### 주요 특징

**내장 서버 (Embedded Server)**
- Tomcat을 내장하고 있어 서버가 계속 유지됩니다.
- 기본 포트 번호: 8080 (Apache Tomcat의 기본 포트)
- 포트 번호 범위: 0~65536
- 80번 포트는 생략 가능합니다.

**JAR 파일**
- 바로 실행 가능한 Spring 프로젝트로 빌드됩니다.
- JVM(JRE)이 있으면 어디서든 실행 가능합니다.
- Docker를 사용하면 JVM을 따로 설치하지 않아도 됩니다.

### spring-boot-starter

모든 Spring Boot 프로젝트가 의존하는 기본 구성 요소들을 포함합니다.

### Spring 주요 모듈

| 모듈 | 설명 | 의존성 |
|------|------|--------|
| **Core** | 근간이 되는 모듈, 리플렉션, 타입 변환, 컬렉션, 예외 처리 등 | - |
| **Beans** | Bean을 관리할 때 필요한 모듈 | Core |
| **Context** | 컨테이너 환경 제공, Spring 컨테이너 생성 코드 포함 | Beans, Core |
| **SpEL** | Spring 표현식 언어(문법) | - |

---

## 빌드와 Gradle

### 컴파일 vs 빌드 (면접 질문)

**컴파일**
- 우리가 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꾸는 작업

**빌드**
- 컴파일한 파일들을 가지고 실행 가능한 상태로 만드는 것 (패키징)

### Gradle

우리가 만든 코드를 실행 가능한 상태(JAR)로 만드는 모든 과정을 처리해주는 프로그램입니다.

**Gradle이 처리하는 작업**
1. 컴파일
2. 라이브러리 다운로드 및 연결
3. 테스트 실행
4. 실행 가능한 애플리케이션 만들기 (패키징)

Gradle은 빌드 툴이면서 동시에 의존성도 관리합니다 (외부 라이브러리).

### 의존성 스코프

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

- **implementation**: compileOnly + runtimeOnly
- **compileOnly**: 컴파일 시에만 필요 (예: Lombok은 애노테이션 기반이므로 compileOnly만 필요)
- **testRuntimeOnly**: 테스트 실행 시 필요

### 라이브러리 검색

[MVN Repository](https://mvnrepository.com/)에서 라이브러리를 검색할 수 있습니다.

### Gradle 명령어

```bash
# Windows
gradlew.bat clean

# CLI 환경에서 테스트 코드만 실행 (면접 질문)
./gradlew test
```

---

## 프로젝트 설정

### 파일 구조

- 도메인은 실행 파일 하위 폴더에 위치해야 합니다.
- `.gradle` 폴더는 Git에서 제외하고 커밋해야 합니다.

### 설정 파일

properties보다 yml을 선호합니다.

```yaml
# application.yml
server:
  port: 8080
```

**주의사항**
- 민감한 정보는 숨겨서 올려야 합니다.
- dev, local 환경은 통합해서 관리하는 것이 좋습니다.

---

## 기타

### Bean 탐색 우선순위

빈은 타입을 먼저 봅니다.

### 서블릿 컨테이너

Tomcat이 서블릿 컨테이너 역할을 합니다.

### Spring 버전 업그레이드

Java 8 → Java 17로 업그레이드 시 패키지가 변경됩니다.
- `javax.*` → `jakarta.*`

---

## 핵심 정리

- **IoC**: 제어권을 Spring에게 위임
- **Bean**: Spring 컨테이너가 관리하는 객체
- **DI**: 생성자 주입 권장, 결합도를 낮춤
- **AOP**: 공통 관심 사항을 분리하여 관리
- **Self-Invocation**: 클래스 내부 메서드 호출에는 AOP가 적용되지 않음
- **빌드**: 컴파일 + 패키징
- **Gradle**: 빌드 툴 + 의존성 관리 도구