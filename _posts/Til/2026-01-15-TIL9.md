---
title:  "TIL - 2026/01/15/목"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-15
last_modified_at: 2026-01-16
---
<br>


# JCF에서 파일 저장소로 전환 시 발생하는 문제들

메모리(JCF)에서 파일(File I/O) 저장 방식으로 바꿨을 때 겪은 문제와 해결 방법을 정리했습니다.

---

## 1. 수정 후 재할당 문제

### 현상
`userService.update()`로 이름을 수정했는데, 다음 줄에서 확인하면 이름이 바뀌지 않았습니다.

### 원인

**JCF 방식**
- 메모리에 있는 객체 주소를 공유합니다.
- 한 곳에서 수정하면 같은 객체를 참조하는 모든 곳에서 변경사항이 보입니다.

**File 방식**
- `load()`를 호출할 때마다 파일에서 새로운 객체를 생성합니다.
- 서비스에서 수정된 객체는 파일에서 새로 만든 객체입니다.
- `Main`의 변수는 수정 전 객체를 참조하고 있어서 변경사항이 보이지 않습니다.

### 해결

수정 후 반환된 최신 객체를 변수에 재할당해야 합니다.

```java
// ❌ 문제: 수정만 하고 변수는 이전 객체 참조
userService.update(id, name, status);

// ✅ 해결: 수정 후 반환된 객체를 변수에 재할당
user1 = userService.update(id, name, status);
```

---

## 2. ID 기반 비교 문제

### 현상
`contains()`로 중복 체크를 했는데, 같은 유저가 채널에 계속 추가되었습니다.

### 원인

**동일성 vs 동등성**
- 자바의 `contains()`는 기본적으로 메모리 주소를 비교합니다.
- 파일에서 읽어오면 내용(ID, 이름)이 같아도 주소가 매번 다릅니다.
- 자바는 다른 객체로 판단하고 리스트에 계속 추가합니다.

### 해결

주소가 아닌 고유값(UUID)을 직접 비교해야 합니다.

```java
// ❌ 문제: 주소값 비교
if (!channels.contains(channel))

// ✅ 해결: ID로 직접 비교
boolean isExist = channels.stream()
    .anyMatch(c -> c.getId().equals(channel.getId()));
if (!isExist) {
    channels.add(channel);
}
```

---

## 3. 엔티티 내부 리스트 관리 문제

### 현상
`User`나 `Channel` 클래스 안에 `List<Message>` 필드를 만들고 데이터를 넣었는데, 나중에 확인하면 비어있거나 옛날 데이터만 있었습니다.

### 원인

**영속성의 한계**
- 파일 저장소 방식에서 객체 내부의 리스트는 스냅샷일 뿐입니다.
- `Message.ser` 파일에 새 메시지가 저장되어도, 이미 메모리에 있는 `Channel` 객체의 리스트는 자동으로 업데이트되지 않습니다.

### 해결

엔티티 내부 리스트에 의존하지 말고, 서비스를 통해 조회해야 합니다.

```java
// ❌ 잘못된 방식: 엔티티 내부 리스트 사용
List<Message> messages = channel.getMessages();

// ✅ 올바른 방식: 서비스를 통해 파일에서 조회
List<Message> messages = messageService.findByChannelId(channel.getId());
```

---

## 파일 저장소 사용 시 핵심 원칙

1. **Write-Back**: 메모리에서 객체를 수정했다면 반드시 `repository.save()`로 파일에 저장해야 합니다.
2. **Always New**: 파일에서 읽어온 객체는 항상 새로운 객체입니다.
3. **Trust only ID**: 객체 비교 시 주소값이 아닌 UUID를 사용해야 합니다.
4. **Service First**: 엔티티 내부 리스트보다 서비스 조회 메서드를 사용해야 합니다.