---
title:  "TIL - 2026/01/20/화"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-20
last_modified_at: 2026-01-20
---
<br>

# File I/O 기초와 활용 실습 : CSV 파일 CRUD 작업

## 1. Optional 사용 시 실수

### 잘못된 코드

```java
Optional<Member> member = ...
if (member == null) {
    return false;
}
```

### 문제점

- Optional은 절대 null이 아닙니다.
- `findFirst()`는 있으면 `Optional.of(value)`, 없으면 `Optional.empty()`를 반환합니다.

### 수정된 코드

```java
if (member.isEmpty()) {
    return false;
}
```

**배운 점**: Optional은 null 체크 대체용이며 `isEmpty()` 또는 `isPresent()`로 존재 여부를 판단해야 합니다.

---

## 2. Optional을 끝까지 끌고 가는 안티패턴

### 불필요한 ifPresent 사용

```java
member.ifPresent(m -> {
    m.setName(newName);
    m.setAge(newAge);
});
```

### 개선된 코드

```java
Member target = member.get();
target.setName(newName);
target.setAge(newAge);
```

**배운 점**: Optional은 존재 여부 확인까지만 사용하고, 실제 로직은 일반 객체로 처리하는 것이 가독성이 좋습니다.

---

## 3. List.remove()에서 타입 실수

### 잘못된 코드

```java
members.remove(member); // Optional<Member>
```

### 문제점

- `members`는 `List<Member>` 타입입니다.
- `remove()`는 `Member` 타입을 받아야 합니다.

### 수정 코드

```java
// 방법 1
members.remove(member.get());

// 방법 2 (더 깔끔함)
members.removeIf(m -> m.getEmail().equals(email));
```

**배운 점**: 컬렉션 API는 제네릭 타입을 정확히 맞춰야 합니다.

---

## 4. Scanner 입력 버퍼 문제

### 증상

`nextInt()` 이후 `nextLine()`이 바로 빈 문자열을 읽습니다.

### 원인

`nextInt()`는 엔터(`\n`)를 소비하지 않습니다.

### 해결 방법 1: 버퍼 제거

```java
int age = scan.nextInt();
scan.nextLine(); // 엔터 제거
```

### 해결 방법 2: 권장 방식

```java
int age = Integer.parseInt(scan.nextLine());
```

**배운 점**: Scanner 사용 시 입력은 `nextLine()`으로 통일하는 것이 가장 안전합니다.

---

## 5. for-each 문으로 배열에 값 대입 시도

### 잘못된 코드

```java
for (String s : arr) {
    s = scan.nextLine();
}
```

### 문제점

- for-each의 변수는 복사본입니다.
- 배열의 실제 값은 변경되지 않습니다.

### 수정 코드

```java
for (int i = 0; i < arr.length; i++) {
    arr[i] = scan.nextLine();
}
```

**배운 점**: for-each는 읽기 전용입니다. 값을 대입하려면 인덱스 기반 for문을 사용해야 합니다.

---

## 6. FileReader / BufferedReader 사용 이유

### 사용한 구조

```java
BufferedReader br = new BufferedReader(new FileReader(FILE_PATH));
```

### 역할

- **FileReader**: 파일의 바이트 데이터를 문자로 변환 (기본 인코딩 사용)
- **BufferedReader**: 버퍼 사용 + `readLine()` 메서드 제공 (성능 향상)

---

## 7. FileReader vs InputStreamReader

### 흔한 오해

"FileReader는 문자를 그대로 읽는다"

### 정확한 이해

FileReader는 파일의 바이트를 플랫폼 기본 인코딩으로 문자로 변환해서 읽습니다.

### 더 안전한 방식

```java
BufferedReader br = new BufferedReader(
    new InputStreamReader(
        new FileInputStream(FILE_PATH),
        StandardCharsets.UTF_8
    )
);
```

**배운 점**: 실무에서는 인코딩을 명시할 수 있는 `InputStreamReader`가 더 안전하고 표준입니다.

---

## 8. Java I/O 스트림 계층 구조

### InputStream/OutputStream (바이트 단위)

바이트 단위 입출력을 위한 최상위 스트림 클래스입니다. 텍스트, 이미지, 영상, 파일 등 모든 데이터를 처리할 수 있습니다.

**주요 구현체**

- **FileInputStream**: 파일에서 바이트 단위로 읽기
- **BufferedInputStream**: 버퍼를 이용한 성능 개선
- **DataInputStream**: 기본 타입 읽기
- **ObjectInputStream**: 객체 역직렬화
- **PrintStream**: 출력 스트림

### Reader/Writer (문자 단위)

문자 단위 입출력을 위한 최상위 스트림 클래스입니다. 텍스트 데이터 전용이며, 내부적으로 인코딩 처리를 포함합니다.

**주요 구현체**

- **FileWriter**: 파일에 문자 쓰기
- **OutputStreamWriter**: 문자 → 바이트 변환 브리지
  ```
  Writer → OutputStreamWriter → OutputStream
  ```
- **BufferedWriter**: 버퍼 사용
  - 직접 파일과 통신하지 않음
  - 기존 스트림을 감싸서 사용
- **PrintWriter**: 출력 편의 기능 제공

### InputStreamReader vs FileReader 차이점

| 특징 | InputStreamReader | FileReader |
|------|------------------|------------|
| 용도 | 범용 브리지 클래스 | 편의용 클래스 |
| 인코딩 지정 | 명확하게 지정 가능 | 플랫폼 기본값 사용 |
| 크로스 플랫폼 | OS가 달라도 결과 동일 | OS마다 다를 수 있음 |
| 한글 처리 | 인코딩 지정으로 깨짐 방지 | 플랫폼에 의존 |
| 권장도 | 실무 권장 | 간단한 테스트용 |

```java
// InputStreamReader - 인코딩 명시
InputStreamReader isr = new InputStreamReader(
    new FileInputStream("file.txt"),
    StandardCharsets.UTF_8
);

// FileReader - 플랫폼 기본 인코딩
FileReader fr = new FileReader("file.txt");
```

---

## 핵심 정리

- Optional은 null이 아닙니다.
- Optional은 존재 체크까지만 사용합니다.
- Scanner는 `nextLine()` 중심으로 사용합니다.
- for-each는 값 대입이 불가능합니다.
- FileReader는 편의용, InputStreamReader는 실무용입니다.
- Buffered 계열은 성능을 위한 래퍼입니다.
- 바이트 스트림은 모든 데이터, 문자 스트림은 텍스트 전용입니다.