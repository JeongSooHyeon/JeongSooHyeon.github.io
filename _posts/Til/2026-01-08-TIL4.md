---
title:  "TIL - 2026/01/08/목"

categories:
  - Til
tags:
  - [Programming, Java]

toc: true
toc_sticky: false
 
date: 2026-01-08
last_modified_at: 2026-01-09
---
<br>

# TIL - Java 람다와 Stream API

---

## 오늘의 나는 무엇을 잘했는가?

너무 어려웠다. stream은 항상 대충 넘어갔어서 거의 처음 듣는 거라 힘들었지만 끝까지 열심히 들었다.

---

## 오늘의 나는 무엇을 배웠을까?

### 1. 컬렉션 순회

#### List
- `for`문으로 순회 가능 (순서가 있기 때문)
- **컬렉션 순회할 때는 `foreach`를 권장** (끝까지 가는 게 보장됨)
- 보통 stream에서 사용됨

#### Map ⭐⭐
- **원칙적으로 순회 안 됨** (Iterable 상속하고 있지 않음)
- Map을 Set으로 변환해서 순회 가능

#### Stack, Queue, PriorityQueue
- Stack 사용 예: 브라우저 앞으로 가기, 뒤로 가기
- **중간 요소에 접근할 수 없음**

---

### 2. 컬렉션 상세

#### Set (집합)

##### HashSet (기본)
- 순서가 없다기보단 **순서가 보장되지 않음**
- 내부적으로 hashtable에 저장
- 1을 저장한다면 해시함수를 거쳐서 임의의 값으로 바꿔서 저장
- 해시값끼리 비교해서 중복 여부 판단
- **효율적인 중복 관리를 위해 HashSet을 사용**

##### LinkedHashSet
- 내부적으로 LinkedList 사용
- **순서 보장 필요할 때 사용**

##### SortedSet
- 순서를 유지해야 할 때 사용

##### 사용법
- 순서 보장 필요하면: **LinkedHashSet** (추천)
- 이메일처럼 중복되면 안 되는 경우 사용
- `get`, `indexOf` 없음
- **null도 1개밖에 못 들어옴**
- 인덱스 기반 탐색 불가

##### 커스텀 객체 사용 시
- **equals와 hashCode를 오버라이딩**해야 함
- `obj instanceof User` 꼭 사용해야 함 (User로 형변환 가능한지 확인)

---

#### Map

##### HashMap (기본)
- 많이 사용함
- 순서 보장 안 됨

##### LinkedHashMap
- 순서 보장 필요할 때 사용

##### SortedMap - TreeMap
- 모든 Tree는 Graph이지만, 반대는 아님
- **조회를 효율적으로 하기 위해 사용**

##### Map의 특징
- **index vs key 차이**:
  - index: 0부터 시작, 순서 증가
  - key: 순서 없고, 여러 가지 타입 가능 (보통 문자열 사용)
- **key는 이름표다**
- **key는 중복 허용 안 됨** ⭐⭐
- **value는 중복 가능** ⭐⭐
- **검색 속도 빠름** (Key를 알면 value를 바로 찾을 수 있음)

##### 주요 메서드
```java
map.put("key", value);
putIfAbsent(); // 해당 key에 이미 값이 존재한다면 덮어쓰지 않음
```

##### 엔트리 (Entry)
- key와 value가 묶여있는 것

##### Map → Set 변환
- `entrySet()` (많이 씀) ⭐
- `keySet()`
- `valueSet()` (피하셈)

##### 유용한 팁
```java
"-".repeat(20); // "-" 20번 반복
```

##### 주의사항
- 변환할 때는 **view**라고 해서 얕은 복사처럼 영향을 끼침 (참조라고 생각)
- 해싱하는 건 **key**임 (key가 그대로 저장되지 않고 해싱됨)

##### Stream 사용 권장 상황
- 데이터가 어마어마하게 많을 때
- key, value를 가공하며 여러 가지 작업을 수행해야 할 때
- **이걸로 쓰셈 (자주 쓰이니까)**

---

#### List

##### ArrayList (기본)
- 기본적으로 ArrayList 사용
- 성능 병목이나 삽입/삭제가 반복되는 경우에만 다른 것으로 변경
- 크기가 동적으로 변함
- `arr[2]` == `list.get(2)`
- `util` import 필수

##### 초기화
```java
List<Integer> list = new ArrayList<>(List.of(1, 2, 3, 4, 5));
```

##### 성능 고려사항
> **CR(⭐⭐⭐)UD**: 삽입/삭제를 위해 조회 성능을 떨어뜨리는 건 비효율적

---

### 3. 람다 표현식 (Lambda Expression)

#### 개념
- 인터페이스 변수로 대입 (익명 구현 객체)
- 시그니처에서 **파라미터와 본문만 남음**
- **메서드 이름이 없음** (익명 함수)

#### 목적 (장점)
1. **짧아진다**
2. **람다만 받을 수 있는 형식이 있음**
   - 일급 객체: 함수가 파라미터처럼 쓰이는 것 (함수의 파라미터화)

#### 타입 추론
- 리턴 타입, 파라미터 타입은 추론함

#### 문법 규칙

##### 파라미터
- 1개일 때: 괄호 생략 가능 (타입도 같이 생략해야 함)
- 괄호와 타입 명시해도 됨

##### 본문
- 메서드 본문이 1줄일 때: 중괄호 생략 가능
- 2줄 이상이면 중괄호 필수

##### 권장 사항
```java
// 추천: 변수만 쓰는 형태 (1개일 때)
name -> System.out.println(name);

// 축약할 수 있는 건 다 하기
```

##### return 문
- `return`은 중괄호 필수
- 뺄 거면 다 빼고, 다 넣을 거면 다 넣으셈

#### 제약사항
- 인터페이스에 추상 메서드 여러 개면 못 씀

#### 변수 캡처
- 람다식 내부에서 외부 지역 변수를 참조할 수 있음
- 그 변수는 반드시 **`final`** 또는 **effectively final**이어야 함
- 편법: list를 final로 써서 사용 (정말 부득이할 때만 쓰셈)

---

### 4. 함수형 인터페이스 (Functional Interface)

#### 개념
- 인터페이스 중 **추상 메서드가 하나만 있는** 인터페이스
- **람다식을 쓰기 위해서는 함수형 인터페이스가 필수**
- `Object`에는 넣을 순 있지만 호출 불가능 (형변환되면서 두고 가기 때문)

#### 특징
- 인터페이스 하나에 람다식 여러 개 할 수 있음 (그때마다 참조해서 익명 객체 만드는 것)

#### 표준 함수형 인터페이스
- 자바에 만들어져 있는 함수형 인터페이스도 있음

#### 함수 디스크립터
- 함수형 인터페이스의 시그니처

#### 실무 팁
- 자바가 만들어주는 함수형 인터페이스를 벗어나면 잘 안 씀

---

### 5. 메서드 참조 (::)

#### 개념
- 람다식을 한 번 더 축약
- 람다식으로 되돌릴 줄 알면 좋음

#### 문법
```java
// 인스턴스 메서드
인스턴스::메서드이름

// static 메서드
클래스이름::메서드이름
```

- 추론이 가능할 때 사용

---

### 6. 생성자 참조 ⭐⭐

- 많이 사용함

---

### 7. Stream API

#### 개념
- **컬렉션을 순회할 때 람다식으로 처리할 수 있도록 해주는 반복자**

#### Stream의 3단계 파이프라인 구조

```
1. 생성 → 2. 중간 연산 (0~n개) → 3. 최종 연산 (1개)
```

##### 1. 생성
- 리스트나 배열을 스트림 타입으로 변경

##### 2. 중간 연산
- 없을 수도 있고, n개일 수도 있음
- 실질적으로 어떤 처리를 하는지 (`filter`, `map` 등)

##### 3. 최종 연산
- 무조건 1번만
- `sum`, `max`, `min`, `collect` (남은 요소 수집해서 변환해서 반환), `foreach` 등

---

#### Stream의 특징

##### 1. 원본 소스 변경하지 않음

##### 2. 일회용
- 한 번 최종 연산을 수행한 스트림은 파이프라인이 닫힘

##### 3. 내부 반복자
- 제어할 수 있는 게 없음
- 언제 실행될지, 어디까지 실행시킬지, 뭘 먼저 실행시킬지
- **요소를 전부 순회하는 건 강제**
- 자기가 알아서 최적의 방법을 찾아 씀

##### 4. 지연 평가 ⭐⭐
- 요소를 소비하면서 한 번에 돔
- 효율적으로 돔
- 모든 중간 연산을 하면서 최종 연산 진행
- **최종 연산을 만나기 전엔 중간 연산은 수행되지 않음**

---

### 8. Stream API의 고급 연산

#### 중간 연산

##### distinct()
- 중복 제거
- 참고: `list → set → list`로 해도 중복 제거됨 (강사님 추천)

##### sorted()
- 정렬
- 옵션 넣어서 정렬 가능
- 특정 함수형 인터페이스 넣으면 됨

##### flatMap()
- 중첩 스트림 구조 평탄화

##### peek()
- 살짝 보는 거
- 디버깅 느낌
- 요즘 많이 쓰진 않음

##### skip()
- 건너뛰기

##### limit() ⭐⭐⭐
- n개 남김
- 제한된 데이터만 가능
- 앞에서 줄이느냐 뒤에서 줄이느냐인데, limit로 5개 찾는 순간 끝나게 코딩

---

#### 최종 연산

##### collect() ⭐⭐⭐
- 수집
- `.collect(Collectors.toList())`
- 남은 요소를 stream → list로 변환해서 반환
- "특정 컬렉션으로 만들어줘!"
- Map (key, value 지정해줘야 함)보다는 **List로 많이 받음**

##### joining()
- 문자열로 만들면서 가공
- 잘 안 씀

##### allMatch(), anyMatch(), noneMatch()
- 반환 타입: boolean

##### findFirst() / findAny()
- 하나만 찾음
- Optional로 반환
- `findFirst()`: 첫 번째 요소
- `findAny()`: 병렬 처리 시 빠른 요소 **(성능 더 좋음)**

---

### 9. 익명 클래스를 활용한 기본 연산

> 가볍게 봐, 잘 안 씀

---

## 오늘의 나는 어떤 어려움이 있었을까?

그냥 다 어려웠다. 람다 표현식도 어려웠고 stream도 어려워서 집중을 많이 했다.

---

## 내일의 나는 무엇을 해야 할까?

- 오늘 배운 내용 실습해보기
  - 람다 표현식 연습
  - Stream API 직접 사용해보기