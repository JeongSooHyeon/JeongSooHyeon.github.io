---
title:  "TIL - 2026/01/14/수"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-14
last_modified_at: 2026-01-14
---
<br>

# Java 직렬화와 Stream API

## 직렬화 (Serialization)

### 기본 설정

직렬화하려는 클래스는 `Serializable` 인터페이스를 구현해야 합니다.

```java
import java.io.Serializable;

public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    // 이하 생략
}
```

**serialVersionUID**: 직렬화 및 역직렬화 수행 시 클래스의 버전을 의미합니다. 역직렬화하려는 클래스의 버전이 기대하는 클래스의 버전과 다르다면 역직렬화에 실패합니다.

### 객체 직렬화하기

```java
Person person = new Person("김철수", 25);

// 파일에 객체 직렬화하기
try (FileOutputStream fos = new FileOutputStream("person.ser");
     ObjectOutputStream oos = new ObjectOutputStream(fos)) {
    oos.writeObject(person);
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 동작 원리

- **try-with-resources**: try 안에 선언된 자원들은 작업이 끝나면 자동으로 닫혀 자원 누수를 방지합니다.
- **FileOutputStream**: 데이터를 바이트 단위로 파일에 보내주는 기초적인 통로를 만듭니다.
- **ObjectOutputStream**: Java 객체를 바이트 형태로 변환(직렬화)하여 파일로 저장하는 역할을 합니다.
- **writeObject()**: 메모리에 있던 객체의 데이터가 바이트 형태로 변환되어 파일에 기록됩니다.

> 프로그램이 종료되어 메모리에서 객체가 사라져도, `person.ser` 파일에는 해당 정보가 남아있습니다.

---

## 역직렬화 (Deserialization)

```java
try (FileInputStream fis = new FileInputStream("person.ser");
     ObjectInputStream ois = new ObjectInputStream(fis)) {
    Person person = (Person) ois.readObject();
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace();
}
```

### 동작 과정

1. 하드디스크에 저장된 `person.ser` 파일(직렬화된 바이트 데이터)을 찾습니다.
2. **역방향 통로 열기**
   - `FileInputStream`: 파일에서 바이트 데이터를 읽어오는 통로
   - `ObjectInputStream`: 바이트 데이터를 객체 형태로 조립
3. **객체 읽기**
   - `readObject()`: 바이트 데이터가 Person 객체로 복원됩니다.
   - Object 타입으로 반환되므로 사용할 타입으로 명시적 형변환이 필요합니다.

---

## 예외 처리

### 1. Checked Exception (반드시 처리해야 함)

#### IOException
- **언제 발생?** 파일 읽기/쓰기, 네트워크 연결 등 외부 장치와의 통로(Stream)에 문제가 생겼을 때
- **예시**: 파일 경로가 잘못되었거나, 디스크 용량이 가득 찼을 때

#### ClassNotFoundException
- **언제 발생?** 역직렬화 시 파일에 저장된 클래스 정보는 있지만, 프로젝트에 해당 클래스 파일(.class)이 없을 때

### 2. Unchecked Exception (RuntimeException)

#### IllegalArgumentException
- **언제 발생?** 메서드에 전달된 인자가 적절하지 않을 때
- **예시**: 
  ```java
  if (sender == null) {
      throw new IllegalArgumentException("메시지 보낸이가 없습니다");
  }
  ```

#### NullPointerException
- **언제 발생?** null 참조 변수의 메서드를 호출하거나 필드에 접근하려 할 때

---

## Stream API

### reduce: 하나의 값으로 응축하기

**동작 방식**: `(결과, 요소) -> 새로운 결과`

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

// 초기값 0에서 시작하여 모든 요소를 더함
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b); // 결과: 10
```

### collect: 원하는 형태로 수집하기

스트림의 요소들을 컬렉션(List, Set, Map)이나 다른 형태로 변환합니다.

```java
// 유저 리스트에서 이름만 뽑아 List<String>으로 만들기
List<String> names = userList.stream()
                             .map(User::getName)
                             .collect(Collectors.toList());
```

---

## Optional 메서드

### orElseThrow()

Optional의 값이 null일 경우 예외를 던지고, 값이 있으면 해당 타입의 객체를 반환합니다.

```java
User user = userRepository.findById(id)
    .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다"));
```

### isPresent()

**반환 타입**: `boolean`

Optional 객체가 값을 가지고 있으면 `true`, 없으면 `false`를 반환합니다.

```java
Optional<User> userOpt = userRepository.findById(id);
if (userOpt.isPresent()) {
    User user = userOpt.get();
    // 값이 있을 때 처리
}
```

### ifPresent()

**반환 타입**: `void`

Optional 객체가 값을 가지고 있으면 주어진 동작을 실행하고, 값이 없으면 아무것도 하지 않습니다.

```java
userRepository.findById(id)
    .ifPresent(user -> System.out.println(user.getName()));
```