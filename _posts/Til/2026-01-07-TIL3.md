---
title:  "TIL - 2026/01/07/수"

categories:
  - Til
tags:
  - [Programming, Java]

toc: true
toc_sticky: false
 
date: 2026-01-07
last_modified_at: 2026-01-07
---
<br>

# TIL - Java 심화 (예외처리, Enum, 컬렉션)



---

## 오늘의 나는 무엇을 잘했는가?

자바 후반부에서 배우는 예외처리, Enum 타입은 볼 때마다 새롭다. 그래서 오늘은 용기 내서 강사님께 못 알아들은 부분 질문을 했다.

---

## 오늘의 나는 무엇을 배웠을까?

### 1. 익명 클래스 (Anonymous Class)

#### 개념
- 추상 클래스나 인터페이스의 구현체를 **그 자리에서 바로 구현**
- 구현 클래스가 없음 (한 단계 건너뛰기)
- 일회성으로 사용

#### 특징
- 해당 메서드 내에서만 사용 가능
- 다른 클래스에서 사용 못 함 (나만 쓸 수 있음)
- 이벤트 처리나 콜백 처리 등에 자주 활용됨

#### 주의사항
- 추상 클래스가 너무 많으면 익명 클래스를 쓰지 않는 것이 좋음
- 사실은 한 번만 쓰는 경우가 더 적음 (설계를 잘 했다면)
- **여러 사람이 계속 익명 클래스를 구현해 쓴다면 설계가 잘못된 것일 수 있음**

---

### 2. 내부 클래스 (Inner Class)

#### 2-1. 멤버 내부 클래스

##### 특징
- 어디선가 `new Outer()`를 하면 자동으로 새로운 `InnerClass`를 갖게 됨
- 외부에서는 이너클래스를 못 씀
- 내부 클래스의 인스턴스는 Outer만 사용

##### 사용하는 이유
- **캡슐화**
- Outer 클래스에서 임시로 사용하기 때문에 밖에서 알 수가 없음
- 해당 내부에서만 접근해서 사용할 수 있게
- 밖에서는 접근하는지 안 하는지도 모름
- Outer의 static 변수에는 언제든 접근 가능

##### 언제 사용?
- 숨겨야 할 때
- 캡슐화해서 동작 과정을 숨기고 싶을 때
- 로직이 복잡해질 때

#### 2-2. 정적 내부 클래스 (Static Inner Class)

> Spring에서는 이것을 더 많이 씀

##### 특징
- Outer가 인스턴스화되기 전에는 static 필드와 메서드만 사용 가능
- **Outer를 인스턴스화하지 않아도 이너클래스를 인스턴스화할 수 있음**
- 정적 내부 클래스는 외부 클래스의 static이 붙은 것만 접근

##### 사용하는 이유
- 응집도를 높여서 너무 많은 클래스를 하나로 묶을 때
- 외부 클래스에 변수를 넣는 경우는 많지 않음
- **그냥 하나를 그룹화하는 용도**로 많이 씀

#### 2-3. 지역 내부 클래스 (Local Inner Class)

> 그렇게 많이 쓰지는 않음

##### 특징
- 특정 지역(메서드 안)에 클래스가 있는 것
- Outer 클래스의 멤버에 접근할 때는 상관없음

##### 제약사항
- 함수의 변수에 접근할 때는 제약사항 있음
- 누군가가 메서드를 호출할 때마다 달라질 수 있으므로
- **지역 변수에 접근할 때는 `final`이 붙거나 `final`처럼 끝까지 값이 변하지 않는 변수만 접근 가능** (effectively final)

---

### 3. Enum (열거 타입)

#### 개념
- **상수의 집합** (파이, 하루의 시간, 일주일의 요일 등)
- 불변, 전역 변수(static)
- 변하지 않고 모두가 똑같은 값을 접근
- 모두가 공유하는 값 (예: 주문 상태)
- 하나의 클래스임 (내부적으로 클래스로 변환됨)

#### 구성 요소
- 필드, 메서드, 생성자(상수는 필수) 추가 가능
- 각각은 객체임 (예: `Day.MONDAY`)
- 각각은 필드, 메서드, 생성자를 가질 수 있음

#### 특징
- 비교 시 `==`로 해도 됨 (상수이므로 다들 똑같은 객체를 사용)
- **컴파일 시점에 오류 파악 가능**
- 순서를 쓰는 것은 위험 (`ordinal()`) - 나중에 추가할 수도 있기 때문

#### 사용법
- Enum에서 조건문 쓸 때는 **switch 사용 권장**
- 생성자 오버로딩 가능하지만 모든 필드를 사용하는 생성자를 대부분 씀
- Enum 상수마다 서로 다른 메서드 구현 가능

#### if보다 switch를 써야 하는 이유
- switch는 enum의 객체가 추가됐을 때 오류를 발생시킨다
- 각각의 case 관리하기 직관적이고 편함

#### 실무 팁
- **상태 코드 관리**
- **권한 관리** (시큐리티에서는 안 씀)
- **에러 코드 관리**
- 지나치게 많은 로직을 Enum에 넣는 것은 피해야 함 (행위를 너무 많이 들고 있으면 별로, 그럼 분리)
- 변환 메서드는 보통 static으로 둠
- **모든 Enum을 한 파일에 몰아넣으면 안 됨** (클래스 안에 enum 선언할 때)
- 도메인으로 관리하는 게 용이함

---

### 4. 예외 처리 ⭐⭐⭐⭐⭐ (매우 중요)

#### 예외 vs 오류(에러)

##### 에러 (Error)
- 컴파일 에러, 실행이 안 되는 것
- 시스템 문제 (OS에서 발생하는 문제)
- **우리가 대응할 수 없는 상황** (심각한 상황)
- 예: 메모리가 가득 참 (스택 오버플로우)
- **핸들링 불가능**
- JVM이 핸들링 (에러 발견 시 현재 메서드에서 처리가 안 되면 위로 올라가다가 맨 위 JVM까지)
- 복구할 수 없어 처리하지 않는 것이 일반적

##### 예외 (Exception)
- **개발자가 처리할 수 있는 문제**

---

#### Exception 종류

##### 1. RuntimeException (Unchecked 예외)
- 예: `NullPointerException`, `IllegalArgumentException`, `IndexOutOfBoundsException`
- **선택적 처리**
- 실행 중에 발생
- `throws` 안 해도 됨 (알아서 위로 보냄)
- **개발자 실수가 대부분**
  - 파라미터 잘못 전달
  - 비즈니스 규칙 위반
  - 복구 불가능한 프로그래밍 오류

##### 2. 비 RuntimeException (Checked 예외)
- 예: `IOException`, `SQLException`
- **반드시 처리 필요**
- 컴파일 단계에서 감지
- 여기서 처리 안 할 거면 `throws`로 던져야 함 (처리할 곳까지)
- JVM이 이해할 수 있는 java → class 파일로 변경할 때 오류가 나는 것
- 우리가 직접 예외를 다룰 때, 외부와 상호작용할 때

---

#### 예외 처리 방법

##### throws
- **남한테 예외를 보내는 것**
- 내 바로 위에만 보냄
- 보내고 보내고 누군가가 try-catch하면 그 위에는 처리 안 해도 됨
- 이유: 실행 코드랑 예외 처리 코드랑 섞이지 않게 하기 위함

##### throw
- **내가 예외를 강제로 발생시키는 것**

##### try-catch
```java
try {
    // 실제 실행할 로직
} catch (Exception e) {
    // 예외가 발생했을 때 핸들링하는 코드
    // catch 여러 개 가능
} finally {
    // 무조건 실행됨 (기록할 때 씀)
    // 자원을 닫을 때 사용
}
```

##### try-with-resources
```java
try (자원 선언) {
    // 실행 코드
} catch (Exception e) {
    // 예외 처리
}
// 자원이 알아서 close됨
```

---

#### 실무 팁

> ⚠️ **예외는 프로그램 흐름을 제어하는 도구가 아님**

1. **catch 블록에서는 절대로 로직을 숨기지 않는다**
   - 에러 삼키기 절대 노노
   - 다른 곳에 영향 줄 수 있음
   - 명확한 메시지를 전달해야 함
   - 다시 예외를 던짐

2. **예외 처리 로직은 공통화하는 것이 좋다**

3. **finally에서 return하지 않도록 한다**

4. **Fail-fast**
   - 미리 실패할 수 있는 (오류나 예외) 상황을 고려해 처리
   - 예: 아이디가 중복되는지 미리 확인하면서 회원가입 진행

5. **예외 전환 및 래핑**
   - 낮은 레벨의 예외를 상위 레벨의 예외로 바꿔 던지는 기술
   - 원인 예외 포함 (e)
   - 내부 구현을 노출하지 않고 추상화 수준을 유지할 수 있음
   - 하나의 예외로 래핑해서 전달 (원본 예외 포함)
   - 호출자에게 더 적절한 정보 전달 가능 (메시지로)

6. **메시지는 구체적으로**
   - 예: 어떤 데이터가 무엇으로 잘못 들어왔다

---

### 5. UML (Unified Modeling Language)

#### 개념
- 시스템을 **시각적으로 표현**하기 위한 표준화된 모델링 언어
- 문서화, 기획할 때 필요
- 복잡한 시스템을 시각적으로 이해하기 위함
- **이미지만큼 직관적인 게 없음**

#### 모델링
- 구조를 잡아 그리는 것

#### 주요 특징
- **명세**: 해야 할 구체적인 것, 어떠한 구조로 개발하고 어떠한 것이 담겨있고, 설명서, 스펙이 담겨있는 문서, 명세를 기반으로 개발함
- **문서화**

#### 종류
1. **구조 다이어그램**: 클래스 다이어그램 (제일 많이 씀)
2. **행위 다이어그램**: 시퀀스 다이어그램

#### 도구
- **Mermaid** 많이 씀
- 문서로서 활용할 때 좋음

---

### 6. 클래스 다이어그램

#### 개념
- 클래스, 속성, 메서드, 객체 간의 관계 표현

#### 클래스 표현법
- `-`: private
- `+`: public

#### 관계 종류
1. **연관 관계**: 필드를 요소로 들고 있을 때
2. **의존 관계**: 잠깐 사용하는 것, 메서드의 인자
3. **집합 관계**: 느슨한 관계 (예: 팀-플레이어), 부분은 전체의 생명주기와 독립적
4. **합성 관계**: 전체 객체가 사라지면 부분 객체도 함께 사라짐, 강한 결합
5. **일반화 (상속)**
6. **구현**

---

### 7. 시퀀스 다이어그램

#### 개념
- 특정한 기능을 호출할 때 내부적으로 어떻게 이뤄지는지 보는 것

---

### 8. 객체지향 프로그래밍의 핵심 ⭐⭐⭐⭐⭐

- **객체지향 프로그래밍의 4가지 핵심 개념** ⭐⭐⭐⭐⭐
- **SOLID 원칙** ⭐⭐⭐⭐⭐

---

### 9. JCF (Java Collection Framework)

#### 컬렉션
- **Framework**: 대신 해주는 대신에 정해진 방식대로 해야 함

#### 제네릭 제약
- 레퍼런스 타입만 가능
- 객체만 가능
- 원시 자료형 안 됨
- 래퍼 클래스는 가능

#### 특징
- 대부분 추상화되어 있음
- 구현체를 써야 함

#### 주요 컬렉션

| 타입 | 구현체 | 특징 |
|------|--------|------|
| List | ArrayList | 순서 유지, 중복 허용 |
| Set | HashSet | 중복 불가, 순서 없음 |
| Map | HashMap | 키-값 쌍, 키 중복 불가 |

### 중요 포인트
- **Enum: 상태 관리, 에러 코드 관리 등 실무에서 자주 사용**
- **내부 클래스: 캡슐화와 응집도를 높이는 데 유용**
- **JCF: 조회 성능을 가장 많이 고려해야 함**

---

## 오늘의 나는 어떤 어려움이 있었을까?

예외 처리를 깊게 이해하기는 힘든 것 같다. 실습을 해야겠다.

---

## 내일의 나는 무엇을 해야 할까?

- 객체지향 프로그래밍의 4가지 핵심 개념 복습하기
- SOLID 원칙 복습하기