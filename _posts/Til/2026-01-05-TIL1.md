---
title:  "TIL - 2026/01/05/화"

categories:
  - Til
tags:
  - [Programming, Java]

toc: true
toc_sticky: false
 
date: 2026-01-05
last_modified_at: 2026-01-06
---
<br>


# TIL - JAVA 고급 과정

> 날짜: 2026-01-05

---

## 오늘의 나는 무엇을 잘했는가?

졸았지만 최대한 필기하려고 노력함

---

## 오늘의 나는 무엇을 배웠을까?

### 📚 학습 자료
- **도서**: 객체지향의 사실과 오해 - 조영호

---

### 1. 메서드 기본 개념

#### 파라미터 vs 전달인자
- **파라미터(Parameter)**: 메서드에 선언되어 있는 변수
- **전달인자(Argument)**: 실제로 메서드를 호출할 때 전달하는 값
- 둘은 다른 개념!

---

### 2. 오버로딩 (Overloading)

#### 개념
- **과적(過積)** - 다형성의 한 형태
- 똑같은 메서드를 과적시키는 것
- 하나의 메서드가 여러 개의 기능으로 동작하도록 만드는 것

#### 규칙
- 메서드 이름이 같아야 함
- 파라미터의 개수나 타입이 달라야 함
- **접근제어자, 반환타입은 아무 상관 없다**

#### 가변인자
- 가변인자는 내부적으로 배열로 변환됨
- 따라서 가변인자와 배열 파라미터를 동시에 사용할 수 없음

---

### 3. 생성자와 this

- `this` 생성자를 사용할 때는 **반드시 맨 위에** 작성해야 함
- Java 25부터는 이 제약이 없어짐

---

### 4. JVM (Java Virtual Machine) ⭐⭐⭐

#### 역할
- `.class` 파일을 컴퓨터가 이해할 수 있는 **기계어**로 변경
- 알아서 OS에 맞게 변환해줌

#### 구조
```
JDK > JRE > JVM
```

#### 컴파일 과정
```
.java 파일 → (컴파일) → .class 파일 → (JVM) → 기계어
```

---

### 5. Runtime Data Area

Java 프로그램이 실행될 때 메모리에 할당되는 영역

#### Method Area
- 메서드 정보 저장
- `static` 변수
- `static final` 변수 (상수)
- 클래스 변수

#### Heap Area
- **참조 자료형 (전부 객체)** 저장
- **GC(Garbage Collector)**가 청소하는 대상
- 아무도 참조하고 있지 않을 때 정리됨 (명시적으로 `null` 대입)

#### Stack Area
- Heap에 있는 객체의 **주소값(참조)** 저장
- **LIFO(Last In First Out)** 구조: 후입선출

---

### 6. GC (Garbage Collector) ⭐⭐⭐

> 매우 중요!!!

#### Stop The World
- GC가 동작하는 동안 **모든 애플리케이션이 멈춤**

#### Mark and Sweep
GC가 객체를 정리하는 과정
1. **Mark**: 모든 객체를 보고 더 이상 참조하지 않는 객체에 표시
   - 쓰윽 체크하고
2. **Sweep**: 표시된 객체 제거 및 메모리 회수
   - 쓰윽 지운다

#### 세대별 관리 (Generational GC)
Heap을 세대별로 나눠서 관리

```
Heap → Young Generation | Old Generation
```

**동작 방식**
- Young에서 시작하여 점점 Old로 이동
- 오랫동안 객체가 삭제되지 않고 살아남은 것 = 어딘가에서 계속 참조하고 있음
- 살아남은 객체 = 지워질 가능성이 거의 없음
- **GC는 주로 Young 영역만 체크** (약 95% 정도)

#### 메모리 누수 주의사항

1. **컬렉션 누수**
   - List 등 사용 시 사용 종료 시 `remove()` 호출

2. **static 변수**
   - 불필요하게 유지하지 않기

3. **문자열**
   - 불변 객체이기 때문에 주의
   - `StringBuilder`를 사용하는 것을 권장

---

### 7. 객체지향 프로그래밍

#### 추상화
- **제일 중요한 개념!**

---

### 8. 상속 (Inheritance)

#### 특징
- Java는 **단일 상속만 지원**
- 계층 관계가 명확함
- **is-a** 관계 (A는 B이다)

---

### 9. 포함 관계 (Composition)

#### 개념
- **has-a** 관계 (A는 B를 가진다)
- 상속보다 **결합도가 낮음** → 느슨한 결합

#### 컴포지션이 유리한 상황
- 단일 상속의 단점을 커버할 때
- 다중 역할이 필요할 때
- **가능하면 상속보다는 컴포지션 사용 권장**

---

### 10. 메서드 오버라이딩 (Overriding)

#### 개념
- 부모 클래스의 메서드를 **덮어쓰기, 재정의, 보수**

#### 규칙
- **시그니처를 변경할 수 없음**
  - 메서드 이름
  - 매개변수
  - 반환 타입
- 접근 제어자는 **더 넓은 범위**로만 변경 가능
- **메서드 바디만 재정의** 가능

#### 제약사항

**static 메서드**
- 오버라이딩이 아니라 **숨김(Hiding)**
- 인스턴스 메서드만 오버라이딩 가능
- 각 클래스에 고정되어 있음 (각기 다른 메서드)

**final 메서드**
- 오버라이딩 불가능
- 클래스에 `final`을 붙이면 상속 자체가 불가능

---

### 11. 동적 바인딩 (Dynamic Binding)

#### 개념
- 실행 시점에 **실제 인스턴스의 타입**을 따라감

#### 예제

```java
// ✅ 가능
Person person1 = new Programmer();
Programmer programmer1 = (Programmer) person1;
programmer1.coding(); // 가능

// ❌ 불가능 (ClassCastException 발생)
Person person2 = new Person();
Programmer programmer2 = (Programmer) person2;
programmer2.coding(); // 불가능 - person2는 실제로 Programmer가 아님
```

---

### 12. 오버로딩 vs 오버라이딩 정리

| 구분 | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
|------|----------------------|----------------------|
| 의미 | 한 개의 메서드가 여러 가지 동작 | 부모 메서드를 재정의 |
| 조건 | 파라미터 개수/타입이 다름 | 시그니처가 동일해야 함 |
| 범위 | 같은 클래스 내 | 상속 관계에서 |
| 다형성 | 컴파일 타임 다형성 | 런타임 다형성 |

---

## 오늘의 나는 어떤 어려움이 있었을까?

크게 어려운 거 없었다

---

## 내일의 나는 무엇을 해야 할까?

- 깃허브 블로그 정리