---
title:  "TIL - 2026/01/19/월"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-19
last_modified_at: 2026-01-20
---
<br>

# 자료구조와 알고리즘 - TIL

## 시간 복잡도 (Big O 표기법)

### 점근적 상한법

데이터의 크기가 커짐에 따라 실행 시간이 얼마나 걸리는지를 나타냅니다. 데이터의 크기가 무한하다면 어디에 수렴할 것인가를 보는 것입니다.

**표기법 종류**
- **Big O (O)**: 최악의 경우 (가장 많이 사용)
- **Theta (Θ)**: 평균
- **Omega (Ω)**: 최선

> Theta와 Omega가 필요한 순간: 정렬 알고리즘에서는 3가지가 필수적입니다.

### 주요 시간 복잡도 (반드시 암기)

| 시간 복잡도 | 설명 | 예시 |
|-----------|------|------|
| O(1) | 상수 시간 | 배열/리스트 인덱스 접근, key-value 자료구조 조회, 스택/큐 데이터 추출, 힙 |
| O(log N) | 로그 시간, 매 연산마다 입력을 절반으로 줄임 | 이진 탐색, 이진 탐색 트리 |
| O(N) | 선형 시간, 입력의 크기에 비례 | 배열 순회, 리스트 탐색 |
| O(N log N) | O(N)과 O(N²) 사이 | Merge Sort, Quick Sort (평균) |
| O(N²) | 이차 시간 | 버블 정렬, 삽입 정렬, 선택 정렬 |

**정렬의 상한선**: 정렬은 N log N보다 빠를 수 없습니다. (Quick Sort 기준)

---

## 공간 복잡도

프로그램이 실행될 때 필요한 메모리 공간을 나타냅니다. 시간 복잡도보다는 덜 중요합니다.

### 예시

**Merge Sort**
- 새 배열이 필요합니다.
- 데이터를 쪼갠 다음 합치면서 정렬합니다.
- 쪼갠 데이터를 담을 공간이 필요하므로 배열은 O(N)만큼 필요합니다.

**피보나치 수열 (DP - 메모이제이션 방식)**
- 공간을 사용하는 대신 훨씬 빠릅니다.
- 재귀함수만 사용하면 성능이 매우 나쁩니다.

---

## 자료구조 분류

### 선형 구조
데이터가 일렬로 순차적으로 나열되어 있습니다.
- Array, List, Stack, Queue, Deque

### 비선형 구조
계층적이거나 선형이 아닌 구조입니다.
- Tree, Graph, Heap

> 모든 트리는 그래프에 속해 있습니다. 이 세상에 있는 모든 것을 그래프로 표현할 수 있습니다. (예: 자동차 내비게이션은 그래프로 최단 거리를 찾아줍니다)

---

## 주요 자료구조

### ArrayList

배열을 사용해서 리스트를 구현합니다.
- **메모리 오버헤드 발생**: 저장 공간이 꽉 차면 더 넓은 공간으로 확장해야 합니다.

### Stack

```java
peek() // 삭제하지 않고 반환만 함
```

### Queue

```java
offer()  // 추가
poll()   // 제거 및 반환
peek()   // 맨 처음 요소 조회
```

### Deque

- Stack + Queue
- 양쪽 모두 입구이자 출구
- 가운데 데이터 처리는 불가능

---

## Map과 Hash

### 해시 함수의 동작

```
key → 해시함수(순수함수) → 임의의 값(인덱스)
```

내부적으로 배열 같은 구조를 사용합니다.

### 순수 함수
동일한 입력에는 동일한 출력만 나옵니다.

### 해시 함수의 특징
1. **결정적** (순수함수)
2. **빠른 계산 속도**
3. **균등한 분포** (충돌 줄이기)

### 해시 충돌 해결 방법

**1. 체이닝 기법**
- 연결 리스트 사용 (요소가 적을 때)
- 트리 사용 (요소가 많을 때, Red-Black Tree)

> 면접 Tip: Red-Black Tree를 굳이 언급할 필요는 없습니다. 언급한다면 "잘은 모르지만 트리의 단점을 보완한 트리라고 알고 있습니다"라고만 말하세요.

**2. 이중 해싱**
- 충돌이 나면 한 번 더 해싱을 합니다.
- 해싱을 여러 번 수행합니다.

### Map vs List

**Map을 사용하는 이유**
- Map은 해시 테이블을 사용합니다.
- Set은 해시 맵을 사용합니다 (key 중복 불가).
- 저장은 느리지만 조회는 O(1)입니다.
- List는 인덱스가 숫자일 뿐 특별한 의미를 부여할 수 없습니다.
- 직관적인 의미를 부여하기 위해 Map을 사용합니다.

---

## 제네릭 (Generics)

### 기본 규칙

```java
// ❌ 원시 타입은 불가능
<int> // 컴파일 에러

// ✅ 래퍼 클래스 사용
<Integer>
```

### 타입 파라미터
일반적으로 사용하는 이름: `T`, `E`, `K`, `V`, `N`

```java
public class Box<T> {
    private T item;
}
```

### 타입 제한

```java
// extends로 클래스와 인터페이스 제한 (순서 중요)
public class Box<T extends Number & Comparable<T>> {
    // T는 Number의 하위 타입이면서 Comparable을 구현해야 함
}
```

### 제네릭 메서드

클래스에 선언된 타입 파라미터와는 별도입니다. 이름을 다르게 하는 것이 좋습니다.

```java
public class Utility {
    // static 메서드에서 사용 가능
    // 타입 파라미터가 결정되는 시점: 메서드가 호출될 때
    public static <E> void printArray(E[] array) {
        for (E element : array) {
            System.out.println(element);
        }
    }
}
```

**extends로 타입을 제한하는 용도로 제네릭을 사용할 수 있어야 합니다.**
- 타입 안정성을 보장합니다.

---

## 와일드카드 (심화)

`?`는 어떤 타입이든 들어올 수 있음을 의미합니다. 범위를 제한하고자 할 때 사용합니다.

### 상한 제한 (Upper Bound)

```java
<? extends T>  // 안전하게 읽기
```

### 하한 제한 (Lower Bound)

```java
<? super T>  // Object까지, 안전하게 쓰기
```

**제네릭으로 만들어 놓은 것을 파라미터로 사용할 때 와일드카드를 사용해야 합니다.**

### 객체 비교 주의사항

```java
// ❌ 캐싱 범위 밖으로 나가면 == 사용 불가
Integer a = 200;
Integer b = 200;
a == b;  // false

// ✅ equals 사용
a.equals(b);  // true
```

---

## File I/O

### 경로 사용 원칙

**절대 경로를 사용하지 마세요!**
- 상대 경로를 사용해야 합니다.
- 다른 컴퓨터에서 접근할 때 오류가 날 수 있습니다.

### 파일 저장의 목적

파일로 저장하면 휘발되지 않습니다 (영속화, 오래 보존).

### 데이터 처리 방식

**바이트 단위 처리**
- `InputStream`, `OutputStream`
- 어떠한 형태(사진, 영상 등)의 데이터도 바이트로 변환해서 전송하는 것이 기본입니다.

**문자 단위 처리**
- `Reader`, `Writer`
- 자바에서 문자는 기본 2바이트입니다.

### 성능 최적화

다뤄야 할 데이터가 클수록 버퍼 스트림을 사용하는 것이 빠릅니다.

```java
BufferedReader
BufferedWriter
```

### serialVersionUID

데이터를 추가하거나 수정할 때 버전을 올려서 사용합니다.

```java
private static final long serialVersionUID = 1L;
```