---
title:  "TIL - 2026/01/16/금"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-16
last_modified_at: 2026-01-16
---
<br>

# 채팅 서비스 구현 과제 회고

## 과제 개요

채팅 서비스 '디스코드'의 핵심 도메인(사용자, 채널, 메시지)을 설계하고, 메모리(JCF)와 파일(File I/O) 환경에서 동작하는 서비스를 구현했습니다.

**핵심 키워드**: 도메인 모델링, 인터페이스 설계, JCF, File I/O, 관심사 분리

---

## 설계의 진화 과정

### Step 1. 서비스 구현 (JCF & File)

처음에는 저장 방식에 따라 서비스 클래스를 각각 만들었습니다.

```java
JCFUserService, FileUserService
```

서비스 로직과 저장 로직이 섞여 있어 유지보수가 어려웠습니다.

### Step 2. Repository 패턴 도입

데이터 저장 로직을 Repository 인터페이스로 분리했습니다. 서비스가 "데이터를 어떻게 저장하는지" 몰라도 되게 만들었습니다.

### Step 3. BasicService와 의존성 주입(DI)

순수 비즈니스 로직만 담은 BasicService를 만들고, 생성자를 통해 필요한 레포지토리를 주입받았습니다. 코드를 수정하지 않고 저장소만 교체할 수 있는 유연한 구조가 되었습니다.

---

## 배운 점

### 인터페이스는 약속이다

인터페이스를 먼저 설계하니 구현체가 JCF든 파일이든 상관없이 협업과 확장이 가능했습니다.

### 결합도는 낮게, 응집도는 높게

관심사 분리(BasicService vs Repository)를 통해 코드의 재사용성이 크게 높아졌습니다.

---

## 구현 중 어려웠던 점

### 1. 객체 직렬화와 데이터 포맷 불일치

**문제 상황**

FileMessageRepository 구현 시, `save()` 메서드는 Map 형태로 저장하고 `saveAll()` 메서드는 List 형태로 저장하면서 충돌이 발생했습니다.

**해결 방법**

자바의 객체 직렬화(Serializable)를 사용할 때는 읽어올 때와 저장할 때의 데이터 타입이 반드시 일치해야 합니다. 리스트를 스트림으로 맵으로 변환하여 저장하는 방식으로 해결했습니다.

```java
// List를 Map으로 변환하여 저장
Map<String, Message> messageMap = messages.stream()
    .collect(Collectors.toMap(Message::getId, message -> message));
```

### 2. final 필드 제약 조건과 데이터 초기화

**문제 상황**

JCF 서비스에서 데이터를 저장하는 `data` 필드를 final로 선언했는데, 데이터를 전체 삭제하거나 일괄 저장할 때 `new HashMap<>()`으로 새 객체를 할당할 수 없었습니다.

**해결 방법**

final은 참조가 고정되는 것이지 내부 내용물까지 고정하는 것이 아닙니다. `data.clear()`와 `data.putAll()`을 사용하여 final 제약을 지키면서 데이터를 변경할 수 있었습니다.

```java
// ❌ final 필드는 재할당 불가
data = new HashMap<>();

// ✅ 내부 내용물 변경은 가능
data.clear();
data.putAll(newData);
```

### 3. 도메인 모델 간의 복잡한 연관관계 처리

**문제 상황**

사용자 삭제 시 그 사용자가 만든 채널은 삭제하고, 참여 중인 채널에서는 이름만 제거하는 등 객체 간 관계를 끊어주는 로직이 복잡했습니다. 메모리에서만 지우고 파일에 다시 저장하지 않으면 데이터가 남는 문제가 있었습니다.

**해결 방법**

비즈니스 로직에서 객체 간의 참조를 수정했다면, 반드시 레포지토리를 통해 영속성(Persistence)을 확보해야 데이터 무결성이 유지됩니다.

```java
// 연관된 데이터 수정 후 반드시 저장
channelRepository.save(updatedChannel);
messageRepository.deleteByUserId(userId);
```

### 4. 관심사 분리와 의존성 주입

**문제 상황**

서비스가 직접 파일을 다루는 것과 레포지토리에 맡기는 것의 차이를 처음에는 느끼기 어려웠습니다. "관심사를 분리한다"는 개념을 실제 코드로 구현하는 과정이 생소했습니다.

**해결 방법**

BasicService를 만들고 레포지토리를 인터페이스로 주입받으니, 서비스 코드는 그대로인데 main에서 한 줄만 바꿔도 저장 방식이 바뀌는 의존성 주입(DI)의 강력함을 확인했습니다.

```java
// main에서 저장소 교체
UserService userService = new BasicUserService(new JCFUserRepository());
// UserService userService = new BasicUserService(new FileUserRepository());
```

---

## 마치며

이번 과제를 통해 인터페이스 설계의 중요성과 관심사 분리의 실질적인 효과를 체감할 수 있었습니다. 특히 의존성 주입을 통해 유연한 구조를 만드는 경험이 가장 값진 배움이었습니다.