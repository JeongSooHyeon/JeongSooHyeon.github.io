---
title:  "TIL - 2026/01/23/금"

categories:
  - Til
tags:
  - [Programming]

toc: true
toc_sticky: false
 
date: 2026-01-23
last_modified_at: 2026-01-23
---
<br>


## 콜백 메커니즘

### 개념

특정 이벤트가 발생했을 때 메서드를 호출시키는 것입니다.

**예시**
- 카카오톡이 왔을 때 알림이 뜨는 것
- 회원가입 시 쿠폰 발행

특정 이벤트가 발행됐을 때 부수적으로 해야 할 일들을 처리합니다.

---

## Spring Boot Starter

### Starter란?

시작하기 위한 것들, 즉 의존성 묶음입니다.

**특징**
- Spring Core는 MVC에 포함되어 있습니다.
- 버전 관리를 신경 쓰지 않아도 됩니다.
- 의존성 선언 시 적절한 것을 선택해서 사용해야 합니다.

---

## 계층형 아키텍처

### Controller

```java
@RestController // @ResponseBody 포함 - 반환값이 JSON으로 직렬화됨
@RequestMapping("/api/users")
public class UserController {
    // 요청과 응답만 담당
}
```

**역할**
- 클라이언트(브라우저)로부터 온 HTTP 요청을 가장 먼저 받습니다.
- 요청과 응답만 담당합니다 (복잡한 로직 처리 X).
- Spring 서버가 받아서 특정 Controller가 처리합니다.

**애노테이션**
- `@RestController`: `@ResponseBody`가 포함되어 메서드의 반환값이 모두 JSON으로 직렬화됩니다.
- `@Controller`: 일반 컨트롤러
- 둘 다 `@Component`가 내장되어 Bean으로 등록됩니다.

### Service

```java
@Service
@Transactional // 트랜잭션 처리는 Service에서 시작
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    // 핵심 비즈니스 로직
}
```

**역할**
- 핵심 비즈니스 로직을 담당합니다.
  - 중복 아이디 체크
  - 회원가입 시 쿠폰 지급
  - 나이 제한 확인

**애노테이션**
- `@Service`: `@Component` 내장, Bean으로 등록
- `@Transactional`: 트랜잭션 처리는 Service에서 시작

### Repository

```java
public interface UserRepository extends JpaRepository<User, Long> {
    // JpaRepository 상속 시 기본 메서드 제공
}
```

**역할**
- DB와 직접 통신하는 역할 (DAO)

**특징**
- `@Repository` 내부적으로 `@Component` 포함 (Spring Data JPA 사용 시 예외 변환 기능 포함)
- `JpaRepository`를 상속받으면 Bean으로 자동 등록됩니다.
- 기본 메서드가 제공됩니다 (save, findById, findAll 등).

---

## 계층 간 의존 관계

### 의존 순서

```
Controller → Service → Repository
```

**중요 원칙**
- 의존 순서를 지켜야 하며, 건너뛰기는 안 됩니다.
- Controller와 Service는 거의 1:1로 매칭됩니다.
- **하위 계층(Repository)은 상위 계층(Service)을 몰라야 합니다.**

### 같은 계층끼리 의존

논리적으로 필요한 경우에만 의존합니다.

**해결 방법**
1. 코디네이터나 매니저를 사용해서 두 객체를 의존하는 새로운 객체를 만듭니다.
2. Service가 Repository를 의존하면서 책임을 좀 더 질 수 있습니다.

### 의존성 주입 권장 방식

```java
@Service
@RequiredArgsConstructor // 생성자 자동 생성
public class UserService {
    private final UserRepository userRepository;
    private final CouponService couponService;
}
```

**결론**
- 생성자 주입만 사용하세요.
- `@Autowired`는 잘 사용하지 않습니다.
- `@RequiredArgsConstructor`를 사용하세요.

---

## 이벤트 기반 아키텍처

### 개념

회원 가입(이벤트) 시 이메일을 보내는 것처럼 특정 이벤트가 발생했을 때 처리합니다.

**장점**
- 결합도를 떨어뜨립니다.
- 수정과 확장이 편합니다.

### 이벤트 구현

```java
// 이벤트 발행
@Service
@RequiredArgsConstructor
public class UserService {
    private final ApplicationEventPublisher eventPublisher;
    
    public void register(User user) {
        // 회원 가입 로직
        eventPublisher.publishEvent(new UserRegisteredEvent(user));
    }
}

// 이벤트 리스너
@Component
public class EmailEventListener {
    @EventListener
    @Async // 비동기 처리
    public void handleUserRegistered(UserRegisteredEvent event) {
        // 이메일 발송
    }
}
```

**주의사항**
- `@Component`를 반드시 붙여야 합니다.
- 이벤트 객체는 별도로 생성하지 않아도 됩니다.
- `@Async`로 비동기 처리가 가능합니다.

---

## DTO (Data Transfer Object)

### 개념

데이터 전송 객체로, 요청을 받고 응답을 보낼 때 사용합니다.

```java
public record UserCreateRequest(
    @NotBlank String username,
    @Email String email,
    @Min(18) int age
) {
    // 레코드: 데이터만 다룸, setter나 생성자 없음
}
```

### Mapper

DTO를 Entity로 변환하거나 그 반대의 작업을 수행합니다.

```java
// DTO -> Entity
User user = userMapper.toEntity(userCreateRequest);

// Entity -> DTO
UserResponse response = userMapper.toDto(user);
```

**build.gradle 설정 주의**
- Lombok이 MapStruct보다 위에 있어야 합니다.

### 유효성 검사

```java
public record UserCreateRequest(
    @NotBlank(message = "이름은 필수입니다")
    String username,
    
    @Email(message = "올바른 이메일 형식이 아닙니다")
    String email,
    
    @Pattern(regexp = "^010-\\d{4}-\\d{4}$", message = "올바른 전화번호 형식이 아닙니다")
    String phoneNumber
) {}
```

정규표현식을 사용한 유효성 검사도 가능합니다.

### Record 사용

레코드는 데이터만 다루며 setter, 생성자 등을 자동으로 생성합니다. DTO를 대체할 수 있습니다.

---

## 중요한 개념 정리

### 반드시 알아야 할 것 (중요도 높음)

1. **Starter가 무엇인지**: 의존성 묶음, 버전 관리 자동화
2. **설정 파일과 프로필**: 환경별 설정 분리 및 적용 방법
3. **이벤트 구조**: 이벤트 발행과 리스너, 비동기 처리

### URL 구조

```
https://www.example.com
```

- `https`: 프로토콜
- `www`: 서브 도메인
- `.com`: 최상위 도메인

---

## 핵심 정리

- **Controller**: 요청과 응답만 담당
- **Service**: 핵심 비즈니스 로직, 트랜잭션 관리
- **Repository**: DB와 직접 통신
- **의존 순서**: Controller → Service → Repository (건너뛰기 불가)
- **하위 계층은 상위 계층을 몰라야 함**
- **생성자 주입** + `@RequiredArgsConstructor` 사용
- **이벤트 기반 아키텍처**로 결합도를 낮춤
- **DTO**는 요청/응답 데이터 전송용, Record 활용 가능