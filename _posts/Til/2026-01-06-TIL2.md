---
title:  "TIL - 2026/01/06/화"

categories:
  - Til
tags:
  - [Programming, Java]

toc: true
toc_sticky: false
 
date: 2026-01-06
last_modified_at: 2026-01-06
---
<br>

# TIL - JAVA 고급 과정



---

## 오늘의 나는 무엇을 잘했는가?

혼자 속삭였지만 강사님의 질문에 대답을 열심히 했다. 대부분 답도 맞았다.

---

## 오늘의 나는 무엇을 배웠을까?

### 1. Object 클래스

- 최상위 클래스, 루트 클래스
- 모든 클래스가 상속받는 클래스
- 범용적으로 사용할 수 있는 메서드들이 구현되어 있음 (`toString()`, `equals()`, `hashCode()` 등)
- **자바에 있는 모든 클래스는 Object 클래스이다**

#### equals()와 hashCode()
- `equals()`가 true일 때는 `hashCode()`도 true여야 함 (반대는 아닐 수도 있음)
- `equals()` 재정의하면 `hashCode()`도 재정의해야 함

---

### 2. 캡슐화 ⭐⭐⭐ (가장 중요)

#### 개념
- **접근제어자와 Getter/Setter가 가장 중요**
- 내부 내용 숨길 수 있다
- 보호 (접근 막음) - 은닉과 보호

#### 캡슐화하는 방법
1. **접근제어자** ⭐⭐⭐
2. **Getter, Setter** ⭐⭐⭐

#### 원칙
일단 접근할 수 없게 막아두는 게 default이고 필요에 따라 여는 게 맞음

#### 접근 제어자
- **1개만 사용 가능**: `public`, `protected`, `default`, `private`
- `private`는 일반 class에 적용 안 됨 (이너클래스는 가능)
- 클래스, 필드, 메서드에 붙여서 불필요한 정보 노출과 접근을 막음

#### 기타 제어자
- **여러 개 사용 가능**: `static`, `final`, `abstract`, `synchronized`
- 상속일 때는 `static`, `final` 사용

#### Lombok
- Getter, Setter를 애노테이션만으로 사용 가능

---

### 3. 자바 패키지

#### 사용 이유
- 응집도 높임
- 관련된 것들만 묶어놓을 수 있다

#### 네이밍 규칙
- 패키지명에 대문자 안 씀
- 띄어쓰기가 필요하면 하위 폴더로 구분
- 예: `order_price` → `order.price`

---

### 4. 불변객체

#### 대표적인 불변 객체
- `String`
- `Integer` (int를 포함하는 wrapper 클래스)
- `LocalDate` (날짜, 시간 관리)

#### 중요한 이유
- **스레드 안전성**: 동시성 문제 해결

#### final 키워드
- 객체 안의 field에 `final`이 붙으면 무조건 초기값이 있어야 함
- 생성자로 객체 만드는 시점에 값을 전달인자로 넣어서 할당하는 것을 보장

#### 주의사항
```java
final int[] arr = {1, 2, 3};
arr = new int[]{4, 5, 6}; // ❌ 불가능
arr[0] = 4; // ✅ 가능
```

#### 깊은 복사 중요!

---

### 5. Java Bean

> ⚠️ Spring Bean과 다른 개념!

#### 정의
- 객체 지향 설계를 위한 규약
- 불변일 수도 아닐 수도 있음

#### 규칙
- 기본 생성자 필수 (명시적으로)
- 모든 field는 `private`로 선언
- Getter/Setter 메서드 (`public`)
- (선택사항) 직렬화
- (선택사항) 패키지에 속해야 함

---

### 6. 다형성 (형변환)

#### 개념
- 다양한 형태로 변환이 가능하다
- 보통 추상화와 같이 묶임
- 메서드 오버라이딩(재정의), 메서드 오버로딩(중복정의)도 다형성

```java
Animal animal = new Cat(); // 상위 클래스로 형변환 가능
```

- 상위 타입에서 하위 타입 참조 가능 (반대는 일부만 가능)
- **상속보다는 인터페이스를 많이 씀**

#### 타입 변환
1. **업캐스팅**: 하위 클래스 → 상위 클래스
   - 자동으로 형변환 가능

2. **다운캐스팅**: 상위 클래스 → 하위 클래스
   - 형변환 연산자 반드시 명시 (자동 X)
   - 될 수도 있고 안 될 수도 있다
   - 예: `car → vehicle → car` (원본이 무엇인지가 중요)
   - **위험함**

#### instanceof 연산자
```java
참조변수 instanceof 클래스명
```
- 참조변수가 해당 클래스로 형변환이 가능한지 확인
- 업캐스팅에는 안 써도 됨 (당연하기 때문)

---

### 7. 추상화 ⭐⭐⭐⭐⭐ (제일 중요! 다음은 다형성)

#### 개념
- 특정할 수 있는 특징만 남김
- 객체의 본질만 남기는 것
- 언제든지 다른 걸로 갈아끼울 수 있음, 뻗어나갈 수 있음

#### 핵심
> "밑에서 뭘 하는지 몰라도 되고 없어도 되고, 모르고 쓸 수 있다."

- 자전거인지 자동차인지 모르고 탈 거라는 것만 알고 코드를 씀
- 공통된 상위 클래스 혹은 인터페이스만 알면 됨
- **유연한 코드 작성 가능**
- 생산성 높임

#### 주의사항
너무 추상화하면 코드가 너무 분리됨 → 적절한 타협 필요

#### 추상화의 종류
1. **추상클래스**: 미완성된 설계도
2. **인터페이스** ⭐⭐⭐ (중요): 공통된 행위만 정의 (메서드)

#### 추상화 방식
- **행위 중심 추상화**: 인터페이스
- **데이터 중심 추상화**: 추상클래스, DTO에서 많이 씀 (인터페이스 X)

---

### 8. 추상 클래스 (Abstract Class)

#### abstract 제어자
- 클래스, 메서드 앞에 붙임 (필드는 안 됨)
- **미완성**을 의미

#### abstract 메서드
- 시그니처만 존재, 바디 없음

#### abstract 클래스
- 하나 이상의 추상 메서드를 포함하거나
- 0개 이상의 추상 메서드를 가지고 있는 클래스

#### 특징
- 추상 클래스로 객체 만들 수 없음 (인스턴스화 X)
- 추상 클래스를 상속받아서 완전한 클래스를 만들어야 함 (구현 클래스)
- 추상 메서드는 무조건 오버라이드해야 함
- 객체 생성을 제한하기 위해 선언된 클래스
- **상속 구조에서 유연한 설계를 위해 사용** ⭐⭐⭐⭐

#### 사용 시기
- 높은 수준의 추상화가 필요할 때
- 계층 관계가 명확할 때

#### 한계
단일 상속 때문에 자유로운 객체지향 설계에 한계가 있다

---

### 9. final 키워드

- **변수**: 인스턴스화 시점에 값 초기화 보장돼야 함 (생성자 필수)
- **메서드**: 오버라이딩 불가
- **클래스**: 상속 불가

---

### 10. 인터페이스 ⭐⭐⭐

#### 특징
- 추상화를 구현하기 위해 가장 많이 씀
- **다중 구현 가능** (`implements`)
- 인터페이스가 인터페이스를 상속받을 수 있음 (다중 상속 가능)

#### 조건
1. 모든 메서드는 추상 메서드
2. 필드는 상수만 가능 (제약된 조건), 거의 안 씀
   - 공통된 필드를 추출하기 힘들어서 잘 하지 않음

#### 접근제어자
- `public`만 가능 (생략되어 있음)
- 상수 선언 시 `public static final` 생략되어 있음 (대문자로 작성)
- 메서드의 접근제어자 생략 시 `public abstract` (private 안 됨)

#### default 메서드
- 본문을 가짐
- 마치 상속받는 것처럼 인터페이스의 모든 구현체는 해당 메서드를 쓸 수 있음
- static이 붙은 것과 비슷함
- 다형성 적용 가능
- 오버라이드 가능 (선택적)

#### static 메서드
- 오버라이드 안 됨
- 클래스에 고정되어 있기 때문
- 클래스 로더 시점에서 바로 로드됨

#### 상속과 구현 동시 사용
- 상속 + 구현 동시에 가능
- **순서: 상속 먼저**

#### 추상클래스 vs 인터페이스
- **추상클래스**: 공통된 필드가 있을 때, 계층 구조가 명확할 때
- **인터페이스**: 행위 중심의 추상화가 필요할 때

> 💡 추상화 레벨이 높을 땐 이것을 설명하는 문서가 있으면 좋다.

---

### 11. SOLID 원칙 ⭐⭐⭐⭐ (면접 중요!)

> 객체지향 5대 원칙 - 예시 코드로 작성할 수 있을 정도로 숙지 필요!
> 생산성이 올라간다

#### 1. SRP (Single Responsibility Principle) - 단일 책임의 원칙
- 하나의 클래스는 하나의 책임만 가져야 한다
- 책임 = 역할 = 변경의 사유
- 책임의 경계가 모호할 때는 여러 책임을 들고 있을 수 있다

#### 2. OCP (Open-Closed Principle) - 개방/폐쇄의 원칙
- 확장에는 열려있고 수정에는 닫혀있어야 한다
- **전략 패턴**: 인터페이스, 구현 클래스, 인터페이스를 참조 중인 서비스 클래스

#### 3. LSP (Liskov Substitution Principle) - 리스코프 치환의 원칙
- 자식 클래스는 부모 클래스를 대체할 수 있어야 한다
- 부모 클래스가 자식 클래스를 대체할 수 있어야 함
- 형변환만 의미하지 않음 (예: 날지 못하는 새는 계약을 깨뜨림)

**사전 조건 (Precondition)**
- 메서드가 실행되기 전 만족해야 하는 조건
- 하위 클래스는 사전 조건을 강화하면 안 됨

**사후 조건 (Postcondition)**
- 메서드 실행 후 만족해야 하는 조건
- 하위 클래스는 사후 조건을 약화하면 안 됨

#### 4. ISP (Interface Segregation Principle) - 인터페이스 분리의 원칙
- 인터페이스 하나에 너무 많은 책임을 지게 하지 마라
- **응집도 높다**: 같은 책임을 가지고 있는 것들이 한 곳에 모여있다

#### 5. DIP (Dependency Inversion Principle) ⭐⭐ - 의존성 역전의 원칙
> Spring 할 때 매우 중요!

- 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 한다
- 상위 모듈(추상화 레벨이 더 높은 것)은 하위 모듈에 의존하면 안 된다
- **하위에 뭐가 있는지 모르고 써야 한다**

**핵심**
- 추상화에 의존하자
- 고수준이 저수준에 직접 의존 X
- **나를 사용하는 쪽에서 객체를 주입해주도록** (의존성 주입) ⭐⭐⭐
- **생성자 주입** (필드에 final 쓸 수 있어야 함)
- 하나하나 뜯어서 설명 가능해야 함

---

### 12. 내부 클래스

#### 목적
- 응집도 높이고, 캡슐화 강화
- 내부 클래스에서 외부 클래스의 변수 사용 가능

#### 1. 정적 내부 클래스 (Static Inner Class)
- 인스턴스화하지 않고 쓸 수 있음

```java
Outer.StaticInner staticInner = new Outer.StaticInner();
```

- 정적 내부 클래스의 일반 메서드는 인스턴스화해서 사용해야 함
- 외부의 필드는 static 필드만 접근할 수 있음
  - 이유: staticInner가 Outer보다 먼저 인스턴스화될 수도 있기 때문

#### 2. 지역 내부 클래스 (Local Inner Class)
- 특정 메서드 안에 선언된 클래스
- 메서드 안에 선언된 필드는 `final`이거나 불변(`effectively final`)인 필드만 접근 가능
- 이유: 다른 곳에서 호출될 때 값이 변하면 안 돼서

#### 3. 익명 내부 클래스 (Anonymous Inner Class)
- 한 번만 쓸 때 사용
- 함수를 파라미터화할 때 (함수형 인터페이스)
- 인터페이스를 구현 클래스 없이 바로 사용
- `new 인터페이스()` 형태로 구현 클래스 과정을 건너뜀
- 구현 클래스를 익명으로 만드는 것

---

## 오늘의 나는 어떤 어려움이 있었을까?

추상클래스, SOLID, 내부클래스는 매번 흐지부지 공부했어서 좀 어려웠고 머리도 꽉꽉 찼다.

---

## 내일의 나는 무엇을 해야 할까?

- 위클리페이퍼 정리